<!DOCTYPE html>
<html lang="en">

  <!-- Head -->
  <head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">    <!-- Metadata, OpenGraph and Schema.org -->
    

    <!-- Standard metadata -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Fortran 90 MPI | Germán H. Flores</title>
    <meta name="author" content="Germán H. Flores">
    <meta name="description" content="High Performance Computing">
    <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website">


    <!-- Bootstrap & MDB -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-GLhlTQ8iRABdZLl6O3oVMWSktQOp6b7In1Zl3/Jr59b6EGGoI1aFkw7cmDA6j6gD" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous">

    <!-- Fonts & Icons -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous">
    <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700%7CRoboto+Slab:100,300,400,500,700%7CMaterial+Icons">

    <!-- Code Syntax Highlighting -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light">

    <!-- Styles -->
    
    <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;">
    
    <link rel="stylesheet" href="/assets/css/main.css">
    <link rel="canonical" href="https://ghflores.github.io/projects/1_project/">
    
    <!-- Dark Mode -->
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark">

    <script src="/assets/js/theme.js"></script>
    <script src="/assets/js/dark_mode.js"></script>
    

  </head>

  <!-- Body -->
  <body class="fixed-top-nav ">

    <!-- Header -->
    <header>

      <!-- Nav Bar -->
      <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top">
        <div class="container">
          <a class="navbar-brand title font-weight-lighter" href="/"><span class="font-weight-bold">Germán </span>H. Flores</a>
          <!-- Navbar Toggle -->
          <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar top-bar"></span>
            <span class="icon-bar middle-bar"></span>
            <span class="icon-bar bottom-bar"></span>
          </button>

          <div class="collapse navbar-collapse flex-row-reverse" id="navbarNav">
            <ul class="navbar-nav ml-auto flex-nowrap">

              <!-- About -->
              <li class="nav-item ">
                <a class="nav-link" href="/">About</a>
              </li>
              

              <!-- Other pages -->
              <li class="nav-item ">
                <a class="nav-link" href="/publications/">Publications</a>
              </li>
              <li class="nav-item ">
                <a class="nav-link" href="/patents/">Patents</a>
              </li>
              <li class="nav-item ">
                <a class="nav-link" href="/projects/">Projects</a>
              </li>

              <!-- Toogle theme mode -->
              <li class="toggle-container">
                <button id="light-toggle" title="Change theme">
                  <i class="fas fa-moon"></i>
                  <i class="fas fa-sun"></i>
                </button>
              </li>
            </ul>
          </div>
        </div>
      </nav>

      <!-- Scrolling Progress Bar -->
      <progress id="progress" value="0">
        <div class="progress-container">
          <span class="progress-bar"></span>
        </div>
      </progress>
    </header>


    <!-- Content -->
    <div class="container mt-5">
      <!-- page.html -->
        <div class="post">

          <header class="post-header">
            <h1 class="post-title">Fortran 90 MPI</h1>
            <p class="post-description">High Performance Computing</p>
          </header>

          <article>
            <h2>Introduction</h2>
<hr class="bg-danger border-2 border-top border-primary-subtle">

<p>Computer power is steadily increasing along with exabytes of data created each day. The computing power doubles every 2 years (Moore’s Law), having an exponential rate of increase. However, Moore’s Law cannot go on forever and one day we are going to reach a fundamental limit in which transistors approach the size of an atom. This technological singularity might be fully replaced or augmented one day with another technology (e.g., quantum computers, more complex multi-core chips). Meanwhile, major silicon companies are making technological breakthroughs to deal with this technlogical singularity as well as deal with othe issues such as clock speed, heat, memory bandwith limitations, etc. Having multicore systems have let to parallel computing to solve challenging problems such as computational chemistry, weather prediction, financial and economic modeling, protein folding, optimization, bioinformatics, climate modeling, and much more.</p>

<p>The project described in this page was a final project I completed when taking an introductory course in High Performance Computing. I learned about parallel machine models and programming models, design principles such as partitioning, communication, agglomeration, mapping, and performance analysis. There are many programming languages, APIs, and parallel programming models for programming parallel computers. The project described here uses Fortran 90 and Message Passing Interface (MPI). Although Fortran has been around for many years and other programming languages have been recently created, Fortran is still used in high-performance computing for scientific and engineering research, including at <a href="https://www.nas.nasa.gov/publications/ams/2015/04-28-15.html" rel="external nofollow noopener" target="_blank"> NASA for mission-critical projects</a>. I hope this project inspires you to research, explore, and practice parallel computing in general.</p>

<h2>Goals | Problem Statement</h2>
<hr class="bg-danger border-2 border-top border-primary-subtle">

<div class="card" style="width: auto;">
  <div class="card-header" style="text-align: center;">
    Given a 2D grid of cells randomly initialized with 0s and 1s
    to denote inactive and active states, respectively, change the state of a cell 
    given the following conditions
  </div>
  <ul class="list-group list-group-flush">
    <li class="list-group-item">1. If 3 neighboring cells are active and the current cell is active, then it remains active</li>
    <li class="list-group-item">2. If 3 neighboring cells are active and the current cell is inactive, then the inactive cell becomes active</li>
    <li class="list-group-item">3. If 2 neighbors are active, the current cell does not change</li>
    <li class="list-group-item">4. All other cases (e.g., more than 3 neighboring cells), the current cell remains inactive if it is already inactive, or becomes inactive if it is active</li>
    <li class="list-group-item">5. Assumme periodic boundary conditions</li>
  </ul>
</div>

<p><br></p>

<h2>Design Process</h2>
<hr class="bg-danger border-2 border-top border-primary-subtle">

<p>In order to solve this problem, the Partition, Communication, Agglomeration, and Mapping (PCAM) process was executed as follows:</p>

<div class="accordion" id="accordionPanelDesignProcess">
    <div class="accordion-item">
        <h2 class="accordion-header" id="panelsStayOpen-Partitionheading">
            <button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#panelsStayOpen-collapsePartition" aria-expanded="true" aria-controls="panelsStayOpen-collapsePartition">
                Partition
            </button>
        </h2>
        <div id="panelsStayOpen-collapsePartition" class="accordion-collapse collapse show" aria-labelledby="panelsStayOpen-Partitionheading">
            <div class="accordion-body">
            For the 1D and 2D domain decomposition of the grid, the grid of active and inactive cells were decomposed in the x or the x-y directions. The general idea is to decompose the data and partition it along the rows or columns in such a way that the data is partitioned equally in order for the tasks to perform the same amount of computation. We can either map each fine-grained task to a 1x1 grid point for a total of (m x n) tasks as shown in Figure 1a, do a 1D domain decomposition along the columns, Figure 1b, or a 2D domain decomposition along the rows and columns, Figure 1c. In either of the latter cases, the data is partitioned equally so the tasks perform the same amount of computation.
            </div>
            <div class="row justify-content-sm-center">
                <div class="col-sm-8 mt-3 mt-md-0">
                    <figure>

  <picture>
    

    <!-- Fallback to the original file -->
    <img src="/assets/img/project1/grid.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" title="partition image" onerror="this.onerror=null; $('.responsive-img-srcset').remove();">
  </picture>

</figure>

                    <div class="caption">
                        Figure 1: Different ways to partition a 4x4 grid. (a) Each 1x1 grid maps to a task, (b) 1D domain partitioning along the columns thus creating 2 (2x4) partitions of the same size, and (c) 2D domain partitioning along the columns and rows, thus creating 4 (2x2) partitions of the same size.
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div class="accordion-item">
        <h2 class="accordion-header" id="panelsStayOpen-Communicationheading">
            <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#panelsStayOpen-collapseCommunication" aria-expanded="false" aria-controls="panelsStayOpen-collapseCommunication">
            Communication
            </button>
        </h2>
        <div id="panelsStayOpen-collapseCommunication" class="accordion-collapse collapse" aria-labelledby="panelsStayOpen-Communicationheading">
            <div class="accordion-body">
                In the communication phase of the design process, the goal is to have the tasks perform concurrent execution while avoiding unnecessary communication between the tasks. Therefore, we need to look at the 8 neighbors surrounding a single grid point. We need to look at the neighbors to the left, right, up, down and diagonals as shown in Figure 2b and 2c. In theory, a single grid point needs to communicate eight times with the surrounding neighbors in order to compute its state. For a simple matrix of size 4x4, Figure 2a, it would require 4x4x8 = 128 communications in total.
            </div>
            <div class="row justify-content-sm-center">
                <div class="col-sm-8 mt-3 mt-md-0">
                    <figure>

  <picture>
    

    <!-- Fallback to the original file -->
    <img src="/assets/img/project1/decomposition.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" title="communication image" onerror="this.onerror=null; $('.responsive-img-srcset').remove();">
  </picture>

</figure>
    
                    <div class="caption">
                        Figure 2: (a) A 4x4 matrix where each cell maps to a task. (b) Ghost cell of the original matrix a. If a 1x1 grid is a task, then this task needs all the information from the 8 neighbors. (c) Directions in which a 1x1 cell must look for the information. This 1x1 cell needs the information from all surrounding 8 neighbors.
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div class="accordion-item">
        <h2 class="accordion-header" id="panelsStayOpen-Agglomerationheading">
            <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#panelsStayOpen-collapseAgglomeration" aria-expanded="false" aria-controls="panelsStayOpen-collapseAgglomeration">
            Agglomeration
            </button>
        </h2>
        <div id="panelsStayOpen-collapseAgglomeration" class="accordion-collapse collapse" aria-labelledby="panelsStayOpen-Agglomerationheading">
            <div class="accordion-body">
                In the agglomeration phase, we need to look a ways of reducing communication costs while maintaining scalability and flexibility. In the 1D decomposition case, if we partition the matrix into column partitions of the same size, Figure 3a, then we just need to send the data of the rightmost and leftmost columns to my neighbors (need to wrap around at the edges). In this case, the 4x4 grid is partitioned into 2x4 partitions, or 2 tasks, each task responsible for 8 grid points. Once I receive the information from my left and right neighbors, I can then use my local information and the information received to build a ghost cell as shown in Figure 3c. In this case, I just need to communicate to the neighbor to my left and to my right. In other words, I just need to send and receive information from my left and right neighbors and doing so I can account for the corners. This type of communication works for the 1D case and this can be verified with the ground truth shown in Figure 3b. 
                <br>
                <br>
                <div class="row justify-content-sm-center">
                    <div class="col-sm-8 mt-3 mt-md-0">
                        <figure>

  <picture>
    

    <!-- Fallback to the original file -->
    <img src="/assets/img/project1/agglomeration-1.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" title="agglomeration image" onerror="this.onerror=null; $('.responsive-img-srcset').remove();">
  </picture>

</figure>
    
                        <div class="caption">
                            Figure 3: (a) A 4x4 matrix with 2 (2x4) partitions. Each partition maps to a task. (b) Ghost cell of the original matrix a. This serves as the ground truth to verify that the communication between the tasks is correct. (c) Directions in which to transfer the information between tasks. A task just needs to send information to its left and right neighbors.
                        </div>
                    </div>
                </div>
                In the 2D case, we need to expand the 1D idea. I need some sort of structured communication in order to avoid too much communication. After looking at different solutions so as to decrease the total number of communications, I found that the best solution was to first send the data to the upper and lower neighbors as shown in Figure 4c. Once a partition received the information from its upper and lower neighbors, the local data and the data received can the be packaged and sent to the neighbors to the left and right as shown in Figure 4d. This takes care of providing the diagonal/corner information. In the end, a partition just needs to communicate a total of 4 times to send the information and 4 times to receive the information. This type of communication works for the 2D case and can be verified with the ground truth shown in Figure 4b.
                <br>
                <br>
                <div class="row justify-content-sm-center">
                    <div class="col-sm-8 mt-3 mt-md-0">
                        <figure>

  <picture>
    

    <!-- Fallback to the original file -->
    <img src="/assets/img/project1/agglomeration-2.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" title="agglomeration image" onerror="this.onerror=null; $('.responsive-img-srcset').remove();">
  </picture>

</figure>
    
                        <div class="caption">
                            Figure 4: (a) A 4x4 matrix with 4 (2x2) partitions. Each partition maps to a task for a total of 4 tasks. (b) Ghost cell of the original matrix a. This serves as the ground truth to verify that the communication between the tasks is correct. (c) Directions in which to initially transfer the information between tasks. A task first needs to send information to its upper and lower neighbors. (d) Once the information from the upper and lower neighbors has been received, a task must then send information to its left and right neighbors. After a task receives all the information from all 4 neighbors, then it can proceed to build a ghost cell and perform the computation.
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div class="accordion-item">
        <h2 class="accordion-header" id="panelsStayOpen-Mappingheading">
            <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#panelsStayOpen-collapseMapping" aria-expanded="false" aria-controls="panelsStayOpen-collapseMapping">
            Mapping
            </button>
        </h2>
        <div id="panelsStayOpen-collapseMapping" class="accordion-collapse collapse" aria-labelledby="panelsStayOpen-Mappingheading">
            <div class="accordion-body">
                In the mapping phase, we need to specify where in the grid each task is to execute in order to minimize execution time. Since we are using domain decomposition and based on the observations during the agglomeration phase, we want to make sure that each task performs the same amount of computation and communication. In the 1D case, this can be accomplished by partitioning the grid vertically into partitions of equal column size as shown in Figure 5a for two different grid sizes. For the 2D case, this can be accomplished by partitioning the grid vertically and horizontally into partitions of equal column and row size as shown in Figure 5b. This ensures that all the tasks perform the same amount of communication.
                <br>
                <br>
                <div class="row justify-content-sm-center">
                    <div class="col-sm-8 mt-3 mt-md-0">
                        <figure>

  <picture>
    

    <!-- Fallback to the original file -->
    <img src="/assets/img/project1/mapping.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" title="mapping image" onerror="this.onerror=null; $('.responsive-img-srcset').remove();">
  </picture>

</figure>
    
                        <div class="caption">
                            Mapping task examples. (a) A 4x4 grid can be partitioned into 2 (2x4) partitions, where each partition corresponds to a task. (b) A 4x4 grid can be partitioned into 4 (2x2) partitions, where each partition corresponds to a task. The processor ranks are mapped in sequential order from left to right, top to bottom.
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>   
</div>
<p><br></p>
<h2>Algorithm Task Logic</h2>
<hr class="bg-danger border-2 border-top border-primary-subtle">

<p>The algorithm presented here made used of the PCAM process outlined above. Each task is assigned to each processor and the task logic for the 1D decomposition case is shown in Algorithm listing 1. The task logic for the 2D decomposition case is shown in Algorithm listing 2. The basic idea of the design is to have a master node that distributes the data to the working nodes. Upon receiving the partition of the data that it needs to work on, the working node then transmits the edge information to its neighbors. Once a working node receives all the information it needs from its neighbors, then it builds the ghost cell and runs the game on its local data. Once it has completed all the computations, the working node then sends its results to the master node. Once the master node receives all the partitions from the workers, the game board is reconstructed and displayed on the screen. This process is executed for X number of iterations.</p>
<div class="card" style="width: auto;">
    <div class="card-header" style="text-align: center;">
    Algorithm 1 - 1D domain decomposition task logic
    </div>
    <div class="card-header" style="text-align: left;">
        Input: a matrix of size (m x n), where m = n
        <br>
        Output: a matrix of size (m x n)
        <br>
        while (number of iterations to execute) {
            <br>
            <span class="tab">/*The master processor is always the processor with rank 0 */</span>
            <br>
            <span class="tab">if (master processor) { </span>
                <br>
                <span class="tab-2">initialize grid;</span>
                <br>
                <span class="tab-2">partition the grid and send a partition to a processor;</span>
                <br>
                <span class="tab-2">receive processed data from each processor;</span>
                <br>
                <span class="tab-2">reconstruct the grid;</span>
                <br>
            <span class="tab">} else { </span>
            <br>
                <span class="tab-2">/* The computation processors start from 1 to n */</span>
                <br>
            <span class="tab-2">receive the partition to process from master processor;</span>
            <br>
            <span class="tab-2">send data to left and right neighbors;</span>
            <br>
            <span class="tab-2">receive data from left and right neighbors;</span>
            <br>
            <span class="tab-2">build ghost cell;</span>
            <br>
            <span class="tab-2">perform computation;</span>
            <br>
            <span class="tab-2">send computed data back to master processor;</span>
            <br>
            <span class="tab">}</span>
            <br>
        }
    </div>
</div>
<p><br></p>
<div class="card" style="width: auto;">
    <div class="card-header" style="text-align: center;">
    Algorithm 2 - 2D domain decomposition task logic
    </div>
    <div class="card-header" style="text-align: left;">
        Input: a matrix of size (m x n), where m = n
        <br>
        Output: a matrix of size (m x n)
        <br>
        while (number of iterations to execute) {
            <br>
            <span class="tab">/*The master processor is always the processor with rank 0 */</span>
            <br>
            <span class="tab">if (master processor) { </span>
                <br>
                <span class="tab-2">initialize grid;</span>
                <br>
                <span class="tab-2">partition the grid and send a partition to a processor;</span>
                <br>
                <span class="tab-2">receive processed data from each processor;</span>
                <br>
                <span class="tab-2">reconstruct the grid;</span>
                <br>
            <span class="tab">} else { </span>
            <br>
                <span class="tab-2">/* The computation processors start from 1 to n */</span>
                <br>
            <span class="tab-2">receive the partition to process from the master processor;</span>
            <br>
            <span class="tab-2">send data to upper and lower neighbors;</span>
            <br>
            <span class="tab-2">receive data from upper and lower neighbors;</span>
            <br>
            <span class="tab-2">send data to left and right neighbors;</span>
            <br>
            <span class="tab-2">receive data from left and right neighbors;</span>
            <br>
            <span class="tab-2">build ghost cell;</span>
            <br>
            <span class="tab-2">perform computation;</span>
            <br>
            <span class="tab-2">send computed data back to master processor;</span>
            <br>
            <span class="tab">}</span>
            <br>
        }
    </div>
</div>
<p><br>
<br></p>
<h2>Source Code - Fortran</h2>
<hr class="bg-danger border-2 border-top border-primary-subtle">

<p>The following listings show the source code for the sequential and 1D decomposition algorithms. Listing sequentialGoL.f90 shows the sequential implementation. Listing parallel1GoL.f90 shows the 1D parallel implementation.</p>
<div class="accordion" id="accordionSourceCode">
    <div class="accordion-item">
        <h2 class="accordion-header">
            <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseSeqAlg" aria-expanded="false" aria-controls="collapseSeqAlg">
            sequentialGoL.f90
            </button>
        </h2>
        <div id="collapseSeqAlg" class="accordion-collapse collapse" data-bs-parent="#accordionSourceCode">    
            <div class="accordion-body">

<figure class="highlight"><pre><code class="language-fortran" data-lang="fortran"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
</pre></td>
<td class="code"><pre><span class="c1">!---------------------------------------------------------------------------------</span><span class="w">
</span><span class="c1">! sequentialGoL.f90</span><span class="w">
</span><span class="c1">!</span><span class="w">
</span><span class="c1">! Sequential algorithm used to check for correctness of parallel version</span><span class="w">
</span><span class="c1">!</span><span class="w">
</span><span class="c1">!	Assumptions: </span><span class="w">
</span><span class="c1">! 		- 1 = cell is active; 0 = cell is inactive</span><span class="w">
</span><span class="c1">!		- The matrix is a square matrix</span><span class="w">
</span><span class="c1">!</span><span class="w">
</span><span class="c1">!	To run this program:</span><span class="w">
</span><span class="c1">!		1. Modify the constants listed below </span><span class="w">
</span><span class="c1">!			- GAMEBOARD_SIZE, ITERATIONS, RANDOM_SEED</span><span class="w">
</span><span class="c1">!		2. Execute the following commands:</span><span class="w">
</span><span class="c1">!			&gt; gfortran sequentialGoL.f90 -o seqgol</span><span class="w">
</span><span class="c1">!			&gt; ./seqgol</span><span class="w">
</span><span class="c1">!</span><span class="w">
</span><span class="c1">! Author: German H. Flores</span><span class="w">
</span><span class="c1">!---------------------------------------------------------------------------------</span><span class="w">
</span><span class="k">PROGRAM</span><span class="w"> </span><span class="n">sequentialGoL</span><span class="w">	
</span><span class="k">implicit</span><span class="w"> </span><span class="k">none</span><span class="w">

</span><span class="c1">!---------------------------------------------------------------------------------</span><span class="w">
</span><span class="c1">! 						ONLY MODIFY THESE CONSTANTS</span><span class="w">
</span><span class="c1">!---------------------------------------------------------------------------------</span><span class="w">
</span><span class="c1">! Declare constants</span><span class="w">
</span><span class="c1">!	- GAMEBOARD_SIZE: 	The size of the square matrix. This creates a</span><span class="w">
</span><span class="c1">!						mxn matrix where m=n</span><span class="w">
</span><span class="c1">!	- ITERATIONS: 		Total number of iterations to execute</span><span class="w">
</span><span class="c1">!	- RANDOM_SEED:		The assignment of 1s and 0s to the board are</span><span class="w">
</span><span class="c1">!						done randomly. This value is used to initialize</span><span class="w">
</span><span class="c1">!						the pseudorandom number generator</span><span class="w">
</span><span class="c1">!---------------------------------------------------------------------------------</span><span class="w">
</span><span class="kt">integer</span><span class="p">,</span><span class="w"> </span><span class="k">parameter</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">GAMEBOARD_SIZE</span><span class="w"> 	</span><span class="o">=</span><span class="w"> </span><span class="mi">9</span><span class="w">
</span><span class="kt">integer</span><span class="p">,</span><span class="w"> </span><span class="k">parameter</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">ITERATIONS</span><span class="w"> 		</span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w">
</span><span class="kt">integer</span><span class="p">,</span><span class="w"> </span><span class="k">parameter</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="nb">RANDOM_SEED</span><span class="w"> 		</span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="c1">!TIME()</span><span class="w">
</span><span class="c1">!---------------------------------------------------------------------------------</span><span class="w">
</span><span class="c1">!						ONLY MODIFY THESE CONSTANTS</span><span class="w">
</span><span class="c1">!---------------------------------------------------------------------------------</span><span class="w">


</span><span class="c1">!---------------------------------------------------------------------------------</span><span class="w">
</span><span class="c1">! Declare variables</span><span class="w">
</span><span class="c1">!---------------------------------------------------------------------------------</span><span class="w">
</span><span class="kt">integer</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">gameBoardSize</span><span class="p">,</span><span class="w"> </span><span class="n">iterationsCount</span><span class="w">
</span><span class="kt">integer</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="k">allocatable</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">gameBoard</span><span class="w"> </span><span class="p">(:,:)</span><span class="w">
</span><span class="c1">!---------------------------------------------------------------------------------</span><span class="w">


</span><span class="c1">!---------------------------------------------------------------------------------</span><span class="w">
</span><span class="c1">! Initialize variables</span><span class="w">
</span><span class="c1">!---------------------------------------------------------------------------------</span><span class="w">
</span><span class="c1">! Dynamically create a square matrix</span><span class="w">
</span><span class="c1">!---------------------------------------------------------------------------------</span><span class="w">
</span><span class="n">gameBoardSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GAMEBOARD_SIZE</span><span class="w">
</span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">gameBoardSize</span><span class="w">
</span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">gameBoardSize</span><span class="w">
</span><span class="k">allocate</span><span class="p">(</span><span class="n">gameBoard</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">))</span><span class="w">

</span><span class="c1">!Initialize matrix to 0 and total number of iterations to execute</span><span class="w">
</span><span class="n">gameBoard</span><span class="p">(:,:)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w">
</span><span class="n">iterationsCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ITERATIONS</span><span class="w">
</span><span class="c1">!---------------------------------------------------------------------------------</span><span class="w">


</span><span class="c1">!---------------------------------------------------------------------------------</span><span class="w">
</span><span class="c1">! MAIN CODE</span><span class="w">
</span><span class="c1">!---------------------------------------------------------------------------------</span><span class="w">
</span><span class="c1">! Display original matrix</span><span class="w">
</span><span class="c1">!write(*,*) 'Empty gameboard:'</span><span class="w">
</span><span class="c1">!call printMatrix(gameBoard,m,n)</span><span class="w">

</span><span class="c1">! Display program configuration</span><span class="w">
</span><span class="k">call</span><span class="w"> </span><span class="n">displayConfiguration</span><span class="p">()</span><span class="w">

</span><span class="c1">! Initialize gameboard (1=alive, 0=dead)</span><span class="w">
</span><span class="k">call</span><span class="w"> </span><span class="n">initializeGameBoard</span><span class="p">(</span><span class="n">gameBoard</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="nb">RANDOM_SEED</span><span class="p">)</span><span class="w">

</span><span class="c1">! Original matrix after assignment of 1s</span><span class="w">
</span><span class="k">write</span><span class="p">(</span><span class="o">*</span><span class="p">,</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="s1">'Gameboard after initialization:'</span><span class="w">
</span><span class="k">call</span><span class="w"> </span><span class="n">printMatrix</span><span class="p">(</span><span class="n">gameBoard</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">)</span><span class="w">

</span><span class="c1">! Run the game</span><span class="w">
</span><span class="k">call</span><span class="w"> </span><span class="n">runGame</span><span class="p">(</span><span class="n">gameBoard</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">iterationsCount</span><span class="p">)</span><span class="w">
</span><span class="c1">!---------------------------------------------------------------------------------</span><span class="w">


</span><span class="c1">!---------------------------------------------------------------------------------</span><span class="w">
</span><span class="c1">!Free memory</span><span class="w">
</span><span class="c1">!---------------------------------------------------------------------------------</span><span class="w">
</span><span class="k">deallocate</span><span class="w"> </span><span class="p">(</span><span class="n">gameBoard</span><span class="p">)</span><span class="w">
</span><span class="c1">!---------------------------------------------------------------------------------</span><span class="w">


</span><span class="c1">!---------------------------------------------------------------------------------</span><span class="w">
</span><span class="c1">! Subroutines</span><span class="w">
</span><span class="c1">!---------------------------------------------------------------------------------</span><span class="w">
</span><span class="k">CONTAINS</span><span class="w">

</span><span class="c1">!---------------------------------------------------------------------------------</span><span class="w">
</span><span class="c1">! Assuming periodic boundary conditions. Creates a ghost cell, which </span><span class="w">
</span><span class="c1">! contains the data plus the edges and corners</span><span class="w">
</span><span class="c1">!---------------------------------------------------------------------------------</span><span class="w">
</span><span class="k">subroutine</span><span class="w"> </span><span class="n">createGhostCell</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">ghostCell</span><span class="p">)</span><span class="w">
	</span><span class="k">implicit</span><span class="w"> </span><span class="k">none</span><span class="w">

	</span><span class="kt">integer</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">mNew</span><span class="p">,</span><span class="w"> </span><span class="n">nNew</span><span class="w">
	</span><span class="kt">integer</span><span class="p">,</span><span class="w"> </span><span class="k">dimension</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">cell</span><span class="w">
	</span><span class="kt">integer</span><span class="p">,</span><span class="w"> </span><span class="k">dimension</span><span class="p">(</span><span class="n">m</span><span class="mi">+2</span><span class="p">,</span><span class="n">n</span><span class="mi">+2</span><span class="p">)</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">ghostCell</span><span class="w">

	</span><span class="c1">! Ghost cell has a total of 4 edges added around the cell</span><span class="w">
	</span><span class="n">mNew</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="w">
	</span><span class="n">nNew</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="w">

	</span><span class="c1">! Copy inner elements</span><span class="w">
	</span><span class="n">ghostCell</span><span class="p">(</span><span class="mi">2</span><span class="p">:</span><span class="n">mNew</span><span class="mi">-1</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="n">nNew</span><span class="mi">-1</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cell</span><span class="p">(:,:)</span><span class="w">

	</span><span class="c1">! Copy corners</span><span class="w">
	</span><span class="n">ghostCell</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cell</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">)</span><span class="w">
	</span><span class="n">ghostCell</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">nNew</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cell</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="w">
	</span><span class="n">ghostCell</span><span class="p">(</span><span class="n">mNew</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cell</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">)</span><span class="w">
	</span><span class="n">ghostCell</span><span class="p">(</span><span class="n">mNew</span><span class="p">,</span><span class="n">nNew</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cell</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="w">

	</span><span class="c1">! Copy side elements - wrap around</span><span class="w">
	</span><span class="n">ghostCell</span><span class="p">(</span><span class="mi">2</span><span class="p">:</span><span class="n">mNew</span><span class="mi">-1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cell</span><span class="p">(:,</span><span class="n">n</span><span class="p">)</span><span class="w">
	</span><span class="n">ghostCell</span><span class="p">(</span><span class="mi">2</span><span class="p">:</span><span class="n">mNew</span><span class="mi">-1</span><span class="p">,</span><span class="n">nNew</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cell</span><span class="p">(:,</span><span class="mi">1</span><span class="p">)</span><span class="w">
	</span><span class="n">ghostCell</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="n">nNew</span><span class="mi">-1</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cell</span><span class="p">(</span><span class="n">m</span><span class="p">,:)</span><span class="w">
	</span><span class="n">ghostCell</span><span class="p">(</span><span class="n">nNew</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="n">nNew</span><span class="mi">-1</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cell</span><span class="p">(</span><span class="mi">1</span><span class="p">,:)</span><span class="w">

	</span><span class="k">return</span><span class="w">
</span><span class="k">end</span><span class="w"> </span><span class="k">subroutine</span><span class="w"> </span><span class="n">createGhostCell</span><span class="w">
</span><span class="c1">!---------------------------------------------------------------------------------</span><span class="w">

</span><span class="c1">!---------------------------------------------------------------------------------</span><span class="w">
</span><span class="c1">! Run the game given the total number of iterations</span><span class="w">
</span><span class="c1">!---------------------------------------------------------------------------------</span><span class="w">
</span><span class="k">subroutine</span><span class="w"> </span><span class="n">runGame</span><span class="p">(</span><span class="n">gameBoard</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">iterations</span><span class="p">)</span><span class="w">
	</span><span class="k">implicit</span><span class="w"> </span><span class="k">none</span><span class="w">

	</span><span class="kt">integer</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">iter</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">iterations</span><span class="w">
	</span><span class="kt">integer</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">mGhostCell</span><span class="p">,</span><span class="w"> </span><span class="n">nGhostCell</span><span class="p">,</span><span class="w"> </span><span class="n">sumTotal</span><span class="w">
	</span><span class="kt">integer</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">centerCell</span><span class="w">
	</span><span class="kt">integer</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="k">dimension</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">gameBoard</span><span class="w">
	</span><span class="kt">integer</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="k">allocatable</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">ghostCell</span><span class="w"> </span><span class="p">(:,:)</span><span class="w">
	</span><span class="kt">integer</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="k">allocatable</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">window</span><span class="w"> </span><span class="p">(:,:)</span><span class="w">

	</span><span class="c1">! Allocate window to look around eight neighbors</span><span class="w">
  	</span><span class="k">allocate</span><span class="p">(</span><span class="n">window</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span><span class="w">
  	</span><span class="k">allocate</span><span class="p">(</span><span class="n">ghostCell</span><span class="p">(</span><span class="n">m</span><span class="mi">+2</span><span class="p">,</span><span class="n">n</span><span class="mi">+2</span><span class="p">))</span><span class="w">
  	</span><span class="n">window</span><span class="p">(:,:)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w">
  	</span><span class="n">ghostCell</span><span class="p">(:,:)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w">

  	</span><span class="n">mGhostCell</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="w">
  	</span><span class="n">nGhostCell</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="w">
  	</span><span class="n">sumTotal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w">

	</span><span class="c1">! Repeat iteration times</span><span class="w">
	</span><span class="k">do</span><span class="p">,</span><span class="w"> </span><span class="n">iter</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">iterations</span><span class="w">

		</span><span class="c1">! Create ghost cell and clear gameboard since it </span><span class="w">
		</span><span class="c1">! will be overwritten with the new results</span><span class="w">
		</span><span class="k">call</span><span class="w"> </span><span class="n">createGhostCell</span><span class="p">(</span><span class="n">gameBoard</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">ghostCell</span><span class="p">)</span><span class="w">
		</span><span class="n">gameBoard</span><span class="p">(:,:)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w">

		</span><span class="c1">! Navigate through the 2D map space</span><span class="w">
		</span><span class="k">do</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="n">mGhostCell</span><span class="mi">-1</span><span class="w">
		 	</span><span class="k">do</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="n">nGhostCell</span><span class="mi">-1</span><span class="w">

				</span><span class="c1">! Create a window around each grid point</span><span class="w">
		  		</span><span class="n">window</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ghostCell</span><span class="p">(</span><span class="n">i</span><span class="mi">-1</span><span class="p">:</span><span class="n">i</span><span class="mi">+1</span><span class="p">,</span><span class="n">j</span><span class="mi">-1</span><span class="p">:</span><span class="n">j</span><span class="mi">+1</span><span class="p">)</span><span class="w">
		  		</span><span class="n">centerCell</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">window</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="c1">!Save indexed cell</span><span class="w">
		  		</span><span class="n">window</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="c1">!Do not account for the element</span><span class="w">
		  			            </span><span class="c1">!in the middle. Just look at the </span><span class="w">
		  			            </span><span class="c1">!8 neighbors</span><span class="w">
		  			            
		  		</span><span class="c1">! Add the eight neighboring values</span><span class="w">
		    	</span><span class="n">sumTotal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">sum</span><span class="p">(</span><span class="n">window</span><span class="p">)</span><span class="w">

		    	</span><span class="c1">! If 3 neighbors are alive, cell will be alive </span><span class="w">
		    	</span><span class="c1">! (if already alive, remains alive; if was dead, </span><span class="w">
		    	</span><span class="c1">! becomes alive)</span><span class="w">
		   		</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sumTotal</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="k">then</span><span class="w">
					</span><span class="n">gameBoard</span><span class="p">(</span><span class="n">i</span><span class="mi">-1</span><span class="p">,</span><span class="n">j</span><span class="mi">-1</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w">

				</span><span class="c1">! If 2 neighbours are alive, no change in cell status.</span><span class="w">
				</span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sumTotal</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="k">then</span><span class="w">
					</span><span class="n">gameBoard</span><span class="p">(</span><span class="n">i</span><span class="mi">-1</span><span class="p">,</span><span class="n">j</span><span class="mi">-1</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">centerCell</span><span class="w">

				</span><span class="c1">! All other cases, cell is dead (if was dead, remains </span><span class="w">
				</span><span class="c1">! dead; if was alive, becomes dead)</span><span class="w">
				</span><span class="k">else</span><span class="w">
					</span><span class="n">gameBoard</span><span class="p">(</span><span class="n">i</span><span class="mi">-1</span><span class="p">,</span><span class="n">j</span><span class="mi">-1</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w">
				</span><span class="k">end</span><span class="w"> </span><span class="k">if</span><span class="w">
		    </span><span class="k">enddo</span><span class="w">
		</span><span class="k">enddo</span><span class="w">

		</span><span class="c1">! Show board after each iteration</span><span class="w">
		</span><span class="k">write</span><span class="p">(</span><span class="o">*</span><span class="p">,</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="s1">'Gameboard after iteration '</span><span class="p">,</span><span class="w"> </span><span class="n">iter</span><span class="p">,</span><span class="w"> </span><span class="s1">' :'</span><span class="w">
		</span><span class="k">call</span><span class="w"> </span><span class="n">printMatrix</span><span class="p">(</span><span class="n">gameBoard</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">)</span><span class="w">

		</span><span class="c1">! Show total number of alive cells in the gameboard</span><span class="w">
		</span><span class="n">sumTotal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">sum</span><span class="p">(</span><span class="n">gameBoard</span><span class="p">)</span><span class="w">
		</span><span class="k">write</span><span class="p">(</span><span class="o">*</span><span class="p">,</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="s1">'Total number of alive cells: '</span><span class="p">,</span><span class="w"> </span><span class="n">sumTotal</span><span class="w">
		</span><span class="k">write</span><span class="p">(</span><span class="o">*</span><span class="p">,</span><span class="s2">"(A)"</span><span class="p">)</span><span class="w"> </span><span class="s1">'-------------------------------------------'</span><span class="w">

	</span><span class="k">enddo</span><span class="w">

	</span><span class="c1">!Free memory</span><span class="w">
	</span><span class="k">deallocate</span><span class="w"> </span><span class="p">(</span><span class="n">window</span><span class="p">,</span><span class="n">ghostCell</span><span class="p">)</span><span class="w">

	</span><span class="k">return</span><span class="w">
</span><span class="k">end</span><span class="w"> </span><span class="k">subroutine</span><span class="w"> </span><span class="n">runGame</span><span class="w">
</span><span class="c1">!---------------------------------------------------------------------------------</span><span class="w">

</span><span class="c1">!---------------------------------------------------------------------------------</span><span class="w">
</span><span class="c1">! Assigns random 1s to 50% of the matrix. Assumes that the board has</span><span class="w">
</span><span class="c1">! been previously initialized with 0s</span><span class="w">
</span><span class="c1">!---------------------------------------------------------------------------------</span><span class="w">
</span><span class="k">subroutine</span><span class="w"> </span><span class="n">initializeGameBoard</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">seed</span><span class="p">)</span><span class="w"> 
	</span><span class="k">implicit</span><span class="w"> </span><span class="k">none</span><span class="w">

	</span><span class="kt">integer</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="w">
	</span><span class="kt">integer</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">mat</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">)</span><span class="w">
	</span><span class="kt">integer</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">totalSize</span><span class="p">,</span><span class="w"> </span><span class="n">seed</span><span class="w">

	</span><span class="n">totalSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m</span><span class="o">*</span><span class="n">n</span><span class="w">

	</span><span class="c1">!Randomly assign 1 to 50% of the cells</span><span class="w">
	</span><span class="k">call</span><span class="w"> </span><span class="n">srand</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span><span class="w">
	</span><span class="k">do</span><span class="w"> </span><span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="nb">ceiling</span><span class="p">(</span><span class="n">totalSize</span><span class="o">*</span><span class="mf">0.50</span><span class="p">)</span><span class="w">
		</span><span class="n">mat</span><span class="p">(</span><span class="nb">ceiling</span><span class="p">(</span><span class="n">rand</span><span class="p">()</span><span class="o">*</span><span class="n">m</span><span class="p">),</span><span class="nb">ceiling</span><span class="p">(</span><span class="n">rand</span><span class="p">()</span><span class="o">*</span><span class="n">n</span><span class="p">))</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w">
	</span><span class="k">enddo</span><span class="w">

	</span><span class="k">return</span><span class="w">
</span><span class="k">end</span><span class="w"> </span><span class="k">subroutine</span><span class="w"> </span><span class="n">initializeGameBoard</span><span class="w">
</span><span class="c1">!---------------------------------------------------------------------------------</span><span class="w">

</span><span class="c1">!---------------------------------------------------------------------------------</span><span class="w">
</span><span class="c1">! Prints a matrix of size mxn to the screen</span><span class="w">
</span><span class="c1">!---------------------------------------------------------------------------------</span><span class="w">
</span><span class="k">subroutine</span><span class="w"> </span><span class="n">printMatrix</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">)</span><span class="w">
	</span><span class="k">implicit</span><span class="w"> </span><span class="k">none</span><span class="w">

	</span><span class="kt">INTEGER</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="w">
  	</span><span class="kt">INTEGER</span><span class="p">,</span><span class="w"> </span><span class="k">DIMENSION</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">mat</span><span class="w">

  	</span><span class="k">write</span><span class="p">(</span><span class="o">*</span><span class="p">,</span><span class="s2">"(A)"</span><span class="p">)</span><span class="w"> </span><span class="s1">'-------------------------------------------'</span><span class="w">
  	</span><span class="k">do</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">m</span><span class="w">
    	</span><span class="k">write</span><span class="p">(</span><span class="o">*</span><span class="p">,</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">mat</span><span class="p">(</span><span class="n">i</span><span class="p">,:))</span><span class="w">
	</span><span class="k">enddo</span><span class="w">
	</span><span class="k">write</span><span class="p">(</span><span class="o">*</span><span class="p">,</span><span class="s2">"(A)"</span><span class="p">)</span><span class="w"> </span><span class="s1">'-------------------------------------------'</span><span class="w">
	</span><span class="k">write</span><span class="p">(</span><span class="o">*</span><span class="p">,</span><span class="s2">"(A)"</span><span class="p">)</span><span class="w"> </span><span class="s1">''</span><span class="w">

	</span><span class="k">return</span><span class="w">
</span><span class="k">end</span><span class="w"> </span><span class="k">subroutine</span><span class="w"> </span><span class="n">printMatrix</span><span class="w">
</span><span class="c1">!---------------------------------------------------------------------------------</span><span class="w">

</span><span class="c1">!---------------------------------------------------------------------------------</span><span class="w">
</span><span class="c1">! Show configuration of the program</span><span class="w">
</span><span class="c1">!---------------------------------------------------------------------------------</span><span class="w">
</span><span class="k">subroutine</span><span class="w"> </span><span class="n">displayConfiguration</span><span class="p">()</span><span class="w">
	</span><span class="k">implicit</span><span class="w"> </span><span class="k">none</span><span class="w">

  	</span><span class="k">write</span><span class="p">(</span><span class="o">*</span><span class="p">,</span><span class="s2">"(A)"</span><span class="p">)</span><span class="w"> </span><span class="s1">'---------------------------------------------------'</span><span class="w">
  	</span><span class="k">write</span><span class="p">(</span><span class="o">*</span><span class="p">,</span><span class="s2">"(A)"</span><span class="p">)</span><span class="w"> </span><span class="s1">'Program configuration: '</span><span class="w">
  	</span><span class="k">write</span><span class="p">(</span><span class="o">*</span><span class="p">,</span><span class="s2">"(A)"</span><span class="p">)</span><span class="w"> </span><span class="s1">'---------------------------------------------------'</span><span class="w">
	</span><span class="k">write</span><span class="p">(</span><span class="o">*</span><span class="p">,</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="s1">'Game board size:'</span><span class="p">,</span><span class="w"> </span><span class="n">GAMEBOARD_SIZE</span><span class="p">,</span><span class="w"> </span><span class="s1">' x '</span><span class="p">,</span><span class="w"> </span><span class="n">GAMEBOARD_SIZE</span><span class="w">
	</span><span class="k">write</span><span class="p">(</span><span class="o">*</span><span class="p">,</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="s1">'Number of iterations:'</span><span class="p">,</span><span class="w"> </span><span class="n">ITERATIONS</span><span class="w">
	</span><span class="k">write</span><span class="p">(</span><span class="o">*</span><span class="p">,</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="s1">'Pseudorandom seed used:'</span><span class="p">,</span><span class="w"> </span><span class="nb">RANDOM_SEED</span><span class="w">
	</span><span class="k">write</span><span class="p">(</span><span class="o">*</span><span class="p">,</span><span class="s2">"(A)"</span><span class="p">)</span><span class="w"> </span><span class="s1">'---------------------------------------------------'</span><span class="w">
	</span><span class="k">write</span><span class="p">(</span><span class="o">*</span><span class="p">,</span><span class="s2">"(A)"</span><span class="p">)</span><span class="w"> </span><span class="s1">''</span><span class="w">

	</span><span class="k">return</span><span class="w">
</span><span class="k">end</span><span class="w"> </span><span class="k">subroutine</span><span class="w"> </span><span class="n">displayConfiguration</span><span class="w">
</span><span class="c1">!---------------------------------------------------------------------------------</span><span class="w">

</span><span class="k">END</span><span class="w"> </span><span class="k">PROGRAM</span><span class="w"> </span><span class="n">sequentialGoL</span>
</pre></td>
</tr></tbody></table></code></pre></figure>

            </div>
        </div>
    </div>
    <div class="accordion-item">
        <h2 class="accordion-header">
            <button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#collapseOne" aria-expanded="true" aria-controls="collapseOne">
            parallel1DGoL.f90
            </button>
        </h2>
        <div id="collapseOne" class="accordion-collapse collapse" data-bs-parent="#accordionSourceCode">
            <div class="accordion-body">

<figure class="highlight"><pre><code class="language-fortran" data-lang="fortran"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305
306
307
308
309
310
311
312
313
314
315
316
317
318
319
320
321
322
323
324
325
326
327
328
329
330
331
332
333
334
335
336
337
338
339
340
341
342
343
344
345
346
347
348
349
350
351
352
353
354
355
356
357
358
359
360
361
362
363
364
365
366
367
368
369
370
371
372
373
374
375
376
377
378
379
380
381
382
383
384
385
386
387
388
389
390
391
392
393
394
395
396
397
398
399
400
401
402
403
404
405
406
407
408
409
410
411
412
413
414
415
416
417
418
419
420
421
422
423
424
425
426
427
428
429
430
431
432
433
434
435
436
437
438
439
440
441
442
443
444
445
446
447
448
449
450
451
452
453
454
455
456
457
458
459
460
461
462
463
464
465
466
467
468
469
470
471
472
473
474
475
476
477
478
479
480
481
482
483
484
485
486
487
488
489
490
491
492
493
494
495
496
497
498
499
500
501
502
503
504
505
506
507
508
509
510
511
512
513
514
515
516
517
518
519
520
521
522
523
524
525
526
527
528
529
530
531
532
533
534
535
536
537
538
539
540
541
542
543
544
545
546
547
548
549
550
551
552
553
554
555
556
557
558
559
560
561
562
563
564
565
566
567
568
569
570
571
572
573
574
575
576
577
578
579
580
581
582
583
584
585
586
587
588
589
590
591
592
593
594
595
596
597
598
599
600
601
602
603
604
605
606
607
608
609
610
611
612
613
614
615
616
617
618
619
620
621
622
623
624
625
626
627
628
629
630
631
632
</pre></td>
<td class="code"><pre><span class="c1">!---------------------------------------------------------------------------------</span><span class="w">
</span><span class="c1">! parallel1DGoL.f90</span><span class="w">
</span><span class="c1">!</span><span class="w">
</span><span class="c1">! Parallel 1D version</span><span class="w">
</span><span class="c1">! </span><span class="w">
</span><span class="c1">!	Assumptions: </span><span class="w">
</span><span class="c1">! 		- 1 = cell is active; 0 = cell is inactive</span><span class="w">
</span><span class="c1">!		- The matrix is a square matrix</span><span class="w">
</span><span class="c1">!		- The size of the 1D partitions is the same. In other words, they </span><span class="w">
</span><span class="c1">!		  must fit evenly across the matrix</span><span class="w">
</span><span class="c1">!		- The assignment of the processors is from left to right starting at 1.</span><span class="w">
</span><span class="c1">!		  Therefore, 1 and numProcs-1 are at the boundary. Processor 0 is the</span><span class="w">
</span><span class="c1">!		  master processor</span><span class="w">
</span><span class="c1">!</span><span class="w">
</span><span class="c1">!	Requirements:</span><span class="w">
</span><span class="c1">!		- The number of processors set in parallel1DGoL.cmd file must be</span><span class="w">
</span><span class="c1">!		  equal to be number of partitions + 1</span><span class="w">
</span><span class="c1">!</span><span class="w">
</span><span class="c1">!	To run this program:</span><span class="w">
</span><span class="c1">!		1. Modify the constants listed below </span><span class="w">
</span><span class="c1">!			- GAMEBOARD_SIZE, ITERATIONS, PARTITON_SIZE, RANDOM_SEED</span><span class="w">
</span><span class="c1">!</span><span class="w">
</span><span class="c1">!		2. Execute with the following commands:</span><span class="w">
</span><span class="c1">!			$ mpif90 parallel1DGoL.f90 -o par1Dgol</span><span class="w">
</span><span class="c1">!			$ ./par1Dgol </span><span class="w">
</span><span class="c1">!</span><span class="w">
</span><span class="c1">!   Program configuration examples:</span><span class="w">
</span><span class="c1">!</span><span class="w">
</span><span class="c1">! 		(GAMEBOARD_SIZE, PARTITION_SIZE, # OF PROCESSORS)</span><span class="w">
</span><span class="c1">!		(     4        ,      2        ,       3        )</span><span class="w">
</span><span class="c1">!		(     9        ,      3        ,       4        )</span><span class="w">
</span><span class="c1">!		(     10       ,      2        ,       6        )</span><span class="w">
</span><span class="c1">!		(     12       ,      3        ,       5        )</span><span class="w">
</span><span class="c1">!		(     16       ,      4        ,       5        )</span><span class="w">
</span><span class="c1">!</span><span class="w">
</span><span class="c1">! Author: German H. Flores</span><span class="w">
</span><span class="c1">!---------------------------------------------------------------------------------</span><span class="w">
</span><span class="k">PROGRAM</span><span class="w"> </span><span class="n">parallel1DGoL</span><span class="w">
</span><span class="k">implicit</span><span class="w"> </span><span class="k">none</span><span class="w">
</span><span class="k">include</span><span class="w"> </span><span class="s1">'mpif.h'</span><span class="w">

</span><span class="c1">!---------------------------------------------------------------------------------</span><span class="w">
</span><span class="c1">! 						ONLY MODIFY THESE CONSTANTS</span><span class="w">
</span><span class="c1">!---------------------------------------------------------------------------------</span><span class="w">
</span><span class="c1">! Declare constants</span><span class="w">
</span><span class="c1">!	- GAMEBOARD_SIZE: 	The size of the square matrix. This creates a</span><span class="w">
</span><span class="c1">!						mxn matrix where m=n</span><span class="w">
</span><span class="c1">!	- ITERATIONS: 		Total number of iterations to execute</span><span class="w">
</span><span class="c1">!	- PARTITION_SIZE:	Total number of vertical partitions</span><span class="w">
</span><span class="c1">!	- RANDOM_SEED:		The assignment of 1s and 0s to the board are</span><span class="w">
</span><span class="c1">!						done randomly. This value is used to initialize</span><span class="w">
</span><span class="c1">!						the pseudorandom number generator</span><span class="w">
</span><span class="c1">!---------------------------------------------------------------------------------</span><span class="w">
</span><span class="kt">integer</span><span class="p">,</span><span class="w"> </span><span class="k">parameter</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">GAMEBOARD_SIZE</span><span class="w"> 	</span><span class="o">=</span><span class="w"> </span><span class="mi">9</span><span class="w">
</span><span class="kt">integer</span><span class="p">,</span><span class="w"> </span><span class="k">parameter</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">ITERATIONS</span><span class="w"> 		</span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w">
</span><span class="kt">integer</span><span class="p">,</span><span class="w"> </span><span class="k">parameter</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">PARTITION_SIZE</span><span class="w"> 	</span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="w">
</span><span class="kt">integer</span><span class="p">,</span><span class="w"> </span><span class="k">parameter</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="nb">RANDOM_SEED</span><span class="w"> 		</span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="c1">!TIME()</span><span class="w">
</span><span class="c1">!---------------------------------------------------------------------------------</span><span class="w">
</span><span class="c1">!						ONLY MODIFY THESE CONSTANTS</span><span class="w">
</span><span class="c1">!---------------------------------------------------------------------------------</span><span class="w">


</span><span class="c1">!---------------------------------------------------------------------------------</span><span class="w">
</span><span class="c1">! Declare variables and other constants</span><span class="w">
</span><span class="c1">!---------------------------------------------------------------------------------</span><span class="w">
</span><span class="kt">integer</span><span class="p">,</span><span class="w"> </span><span class="k">parameter</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">LEFT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w">
</span><span class="kt">integer</span><span class="p">,</span><span class="w"> </span><span class="k">parameter</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">RIGHT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w">

</span><span class="kt">integer</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">tag</span><span class="p">,</span><span class="w"> </span><span class="nb">count</span><span class="p">,</span><span class="w"> </span><span class="n">iter</span><span class="w">
</span><span class="kt">integer</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">lowerLimit</span><span class="p">,</span><span class="w"> </span><span class="n">upperLimit</span><span class="w">
</span><span class="kt">integer</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">procID</span><span class="w">
</span><span class="kt">integer</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">blockID</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="w">
</span><span class="kt">integer</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="k">allocatable</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">gameBoard</span><span class="w"> </span><span class="p">(:,:)</span><span class="w">
</span><span class="kt">integer</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="k">allocatable</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">ghostCell</span><span class="w"> </span><span class="p">(:,:)</span><span class="w">
</span><span class="kt">integer</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="k">allocatable</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">boardSection</span><span class="w"> </span><span class="p">(:,:)</span><span class="w">
</span><span class="kt">integer</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="k">allocatable</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">sectionResult</span><span class="w"> </span><span class="p">(:,:)</span><span class="w">

</span><span class="kt">integer</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="k">allocatable</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">send_request_handles</span><span class="p">(:)</span><span class="w">
</span><span class="kt">integer</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="k">allocatable</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">recv_request_handles</span><span class="p">(:)</span><span class="w">
</span><span class="kt">integer</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="k">allocatable</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">send_request_stats</span><span class="p">(:,:)</span><span class="w">
</span><span class="kt">integer</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="k">allocatable</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">recv_request_stats</span><span class="p">(:,:)</span><span class="w">
</span><span class="kt">integer</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">recv_request_handle</span><span class="p">,</span><span class="w"> </span><span class="n">send_request_handle</span><span class="w">
</span><span class="kt">integer</span><span class="p">(</span><span class="nb">kind</span><span class="o">=</span><span class="mi">4</span><span class="p">),</span><span class="w"> </span><span class="k">dimension</span><span class="p">(</span><span class="n">MPI_STATUS_SIZE</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">recv_request_stat</span><span class="w">
</span><span class="kt">integer</span><span class="p">(</span><span class="nb">kind</span><span class="o">=</span><span class="mi">4</span><span class="p">),</span><span class="w"> </span><span class="k">dimension</span><span class="p">(</span><span class="n">MPI_STATUS_SIZE</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">send_request_stat</span><span class="w">

</span><span class="kt">integer</span><span class="w"> </span><span class="n">myid</span><span class="p">,</span><span class="w"> </span><span class="n">ierr</span><span class="p">,</span><span class="w"> </span><span class="n">numprocs</span><span class="p">,</span><span class="w"> </span><span class="n">errcode</span><span class="p">,</span><span class="w"> </span><span class="n">masterProcessor</span><span class="w">
</span><span class="kt">integer</span><span class="w"> </span><span class="n">stat</span><span class="p">(</span><span class="n">MPI_STATUS_SIZE</span><span class="p">)</span><span class="w">

</span><span class="kt">integer</span><span class="p">(</span><span class="nb">kind</span><span class="o">=</span><span class="mi">4</span><span class="p">),</span><span class="w"> </span><span class="k">dimension</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">request_recv</span><span class="w">
</span><span class="kt">integer</span><span class="p">(</span><span class="nb">kind</span><span class="o">=</span><span class="mi">4</span><span class="p">),</span><span class="w"> </span><span class="k">dimension</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">request_send</span><span class="w">
</span><span class="kt">integer</span><span class="p">(</span><span class="nb">kind</span><span class="o">=</span><span class="mi">4</span><span class="p">),</span><span class="w"> </span><span class="k">dimension</span><span class="p">(</span><span class="n">MPI_STATUS_SIZE</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">stat_send</span><span class="w">
</span><span class="kt">integer</span><span class="p">(</span><span class="nb">kind</span><span class="o">=</span><span class="mi">4</span><span class="p">),</span><span class="w"> </span><span class="k">dimension</span><span class="p">(</span><span class="n">MPI_STATUS_SIZE</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">stat_recv</span><span class="w">

</span><span class="kt">integer</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">leftDestination</span><span class="p">,</span><span class="w"> </span><span class="n">rightDestination</span><span class="w">

</span><span class="c1">! Create custom BlockColumn derived type</span><span class="w">
</span><span class="c1">! This is used to hold a column data to transfer to the</span><span class="w">
</span><span class="c1">! neighbors. The id identifies the column as either left</span><span class="w">
</span><span class="c1">! or right column. This is used to ensure the correct</span><span class="w">
</span><span class="c1">! column in appended to the correct side of the neighbor</span><span class="w">
</span><span class="k">type</span><span class="w"> </span><span class="n">BlockColumn</span><span class="w">
    </span><span class="k">sequence</span><span class="w"> </span><span class="c1">!force the derived type to be stored contiguously</span><span class="w">
    </span><span class="kt">integer</span><span class="w"> </span><span class="n">id</span><span class="w">
    </span><span class="kt">integer</span><span class="p">(</span><span class="nb">kind</span><span class="o">=</span><span class="mi">4</span><span class="p">),</span><span class="w"> </span><span class="k">dimension</span><span class="p">(</span><span class="n">GAMEBOARD_SIZE</span><span class="p">)</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">bColumn</span><span class="w">
</span><span class="k">end</span><span class="w"> </span><span class="k">type</span><span class="w"> </span><span class="n">BlockColumn</span><span class="w">

</span><span class="c1">! Create custom BlockSection derived type</span><span class="w">
</span><span class="c1">! This is used to hold the section of the board that a given</span><span class="w">
</span><span class="c1">! processor is to process. The id is the rank of the processor</span><span class="w">
</span><span class="c1">! that processed the given section</span><span class="w">
</span><span class="k">type</span><span class="w"> </span><span class="n">BlockSection</span><span class="w">
    </span><span class="k">sequence</span><span class="w">
    </span><span class="kt">integer</span><span class="w"> </span><span class="n">id</span><span class="w">
    </span><span class="kt">integer</span><span class="p">(</span><span class="nb">kind</span><span class="o">=</span><span class="mi">4</span><span class="p">),</span><span class="w"> </span><span class="k">dimension</span><span class="p">(</span><span class="n">GAMEBOARD_SIZE</span><span class="p">,</span><span class="w"> </span><span class="n">PARTITION_SIZE</span><span class="p">)</span><span class="w"> </span><span class="p">&amp;</span><span class="w">
        </span><span class="p">::</span><span class="w"> </span><span class="n">bSection</span><span class="w">
</span><span class="k">end</span><span class="w"> </span><span class="k">type</span><span class="w"> </span><span class="n">BlockSection</span><span class="w">

</span><span class="c1">! Derived types used to store the data sent/received by the </span><span class="w">
</span><span class="c1">! processors</span><span class="w">
</span><span class="k">type</span><span class="w"> </span><span class="p">(</span><span class="n">BlockColumn</span><span class="p">)</span><span class="w"> </span><span class="n">block_column_send</span><span class="w">
</span><span class="k">type</span><span class="w"> </span><span class="p">(</span><span class="n">BlockColumn</span><span class="p">)</span><span class="w"> </span><span class="n">block_column_recv</span><span class="w">
</span><span class="k">type</span><span class="w"> </span><span class="p">(</span><span class="n">BlockColumn</span><span class="p">)</span><span class="w"> </span><span class="n">block_columns_recv</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="w">

</span><span class="k">type</span><span class="w"> </span><span class="p">(</span><span class="n">BlockSection</span><span class="p">)</span><span class="w"> </span><span class="n">block_section_send</span><span class="w">
</span><span class="k">type</span><span class="w"> </span><span class="p">(</span><span class="n">BlockSection</span><span class="p">)</span><span class="w"> </span><span class="n">block_section_recv</span><span class="w">
</span><span class="k">type</span><span class="w"> </span><span class="p">(</span><span class="n">BlockSection</span><span class="p">)</span><span class="w"> </span><span class="n">block_sections_recv</span><span class="p">(</span><span class="n">PARTITION_SIZE</span><span class="p">)</span><span class="w">

</span><span class="kt">integer</span><span class="w"> </span><span class="n">blockColumnType</span><span class="p">,</span><span class="w"> </span><span class="n">oldtypes</span><span class="p">(</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">blockcounts</span><span class="p">(</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">)</span><span class="w">
</span><span class="kt">integer</span><span class="w"> </span><span class="n">offsets</span><span class="p">(</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">extent</span><span class="w">
</span><span class="kt">integer</span><span class="w"> </span><span class="n">blockSectionType</span><span class="w">

</span><span class="k">call</span><span class="w"> </span><span class="n">MPI_INIT</span><span class="p">(</span><span class="n">ierr</span><span class="p">)</span><span class="w">
    </span><span class="k">call</span><span class="w"> </span><span class="n">MPI_COMM_RANK</span><span class="p">(</span><span class="n">MPI_COMM_WORLD</span><span class="p">,</span><span class="w"> </span><span class="n">myid</span><span class="p">,</span><span class="w"> </span><span class="n">ierr</span><span class="p">)</span><span class="w">
    </span><span class="k">call</span><span class="w"> </span><span class="n">MPI_COMM_SIZE</span><span class="p">(</span><span class="n">MPI_COMM_WORLD</span><span class="p">,</span><span class="w"> </span><span class="n">numprocs</span><span class="p">,</span><span class="w"> </span><span class="n">ierr</span><span class="p">)</span><span class="w">

</span><span class="c1">!--------------------------------------------------------------</span><span class="w">
</span><span class="c1">! Initialize BlockColumn type</span><span class="w">
</span><span class="c1">!--------------------------------------------------------------</span><span class="w">
</span><span class="c1">! Setup description of the MPI_INTEGER ID </span><span class="w">
</span><span class="n">offsets</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w">
</span><span class="n">oldtypes</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MPI_INTEGER</span><span class="w">
</span><span class="n">blockcounts</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w">

</span><span class="c1">! Setup description of the 2 MPI_INTEGER fields</span><span class="w">
</span><span class="k">call</span><span class="w"> </span><span class="n">MPI_TYPE_EXTENT</span><span class="p">(</span><span class="n">MPI_INTEGER</span><span class="p">,</span><span class="w"> </span><span class="n">extent</span><span class="p">,</span><span class="w"> </span><span class="n">ierr</span><span class="p">)</span><span class="w">
</span><span class="n">offsets</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">extent</span><span class="w">
</span><span class="n">oldtypes</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MPI_INTEGER</span><span class="w">
</span><span class="n">blockcounts</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GAMEBOARD_SIZE</span><span class="w">

</span><span class="c1">! Now define structured type and commit it </span><span class="w">
</span><span class="k">call</span><span class="w"> </span><span class="n">MPI_TYPE_STRUCT</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">blockcounts</span><span class="p">,</span><span class="w"> </span><span class="n">offsets</span><span class="p">,</span><span class="w"> </span><span class="n">oldtypes</span><span class="p">,</span><span class="w"> </span><span class="p">&amp;</span><span class="w"> 
    </span><span class="n">blockColumnType</span><span class="p">,</span><span class="w"> </span><span class="n">ierr</span><span class="p">)</span><span class="w">
</span><span class="k">call</span><span class="w"> </span><span class="n">MPI_TYPE_COMMIT</span><span class="p">(</span><span class="n">blockColumnType</span><span class="p">,</span><span class="w"> </span><span class="n">ierr</span><span class="p">)</span><span class="w">
</span><span class="c1">!--------------------------------------------------------------</span><span class="w">
</span><span class="c1">! Initialize BlockSection type</span><span class="w">
</span><span class="c1">!--------------------------------------------------------------</span><span class="w">
</span><span class="c1">! Setup description of the MPI_INTEGER ID </span><span class="w">
</span><span class="n">offsets</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w">
</span><span class="n">oldtypes</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MPI_INTEGER</span><span class="w">
</span><span class="n">blockcounts</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w">

</span><span class="c1">! Setup description of the 2 MPI_INTEGER fields</span><span class="w">
</span><span class="k">call</span><span class="w"> </span><span class="n">MPI_TYPE_EXTENT</span><span class="p">(</span><span class="n">MPI_INTEGER</span><span class="p">,</span><span class="w"> </span><span class="n">extent</span><span class="p">,</span><span class="w"> </span><span class="n">ierr</span><span class="p">)</span><span class="w">
</span><span class="n">offsets</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">extent</span><span class="w">
</span><span class="n">oldtypes</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MPI_INTEGER</span><span class="w">
</span><span class="n">blockcounts</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GAMEBOARD_SIZE</span><span class="o">*</span><span class="n">PARTITION_SIZE</span><span class="w">

</span><span class="c1">! Now define structured type and commit it </span><span class="w">
</span><span class="k">call</span><span class="w"> </span><span class="n">MPI_TYPE_STRUCT</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">blockcounts</span><span class="p">,</span><span class="w"> </span><span class="n">offsets</span><span class="p">,</span><span class="w"> </span><span class="n">oldtypes</span><span class="p">,</span><span class="w"> </span><span class="p">&amp;</span><span class="w"> 
    </span><span class="n">blockSectionType</span><span class="p">,</span><span class="w"> </span><span class="n">ierr</span><span class="p">)</span><span class="w">
</span><span class="k">call</span><span class="w"> </span><span class="n">MPI_TYPE_COMMIT</span><span class="p">(</span><span class="n">blockSectionType</span><span class="p">,</span><span class="w"> </span><span class="n">ierr</span><span class="p">)</span><span class="w">
</span><span class="c1">!--------------------------------------------------------------</span><span class="w">

</span><span class="c1">! Initialize other variables and allocate memory</span><span class="w">
</span><span class="n">masterProcessor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w">
</span><span class="n">tag</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">777</span><span class="w">
</span><span class="nb">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w">

</span><span class="c1">! Dynamically allocate memory</span><span class="w">
</span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GAMEBOARD_SIZE</span><span class="w">
</span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GAMEBOARD_SIZE</span><span class="w">
</span><span class="k">allocate</span><span class="p">(</span><span class="n">gameBoard</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">))</span><span class="w">
</span><span class="k">allocate</span><span class="p">(</span><span class="n">ghostCell</span><span class="p">(</span><span class="n">m</span><span class="mi">+2</span><span class="p">,</span><span class="n">PARTITION_SIZE</span><span class="mi">+2</span><span class="p">))</span><span class="w">
</span><span class="k">allocate</span><span class="p">(</span><span class="n">boardSection</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">PARTITION_SIZE</span><span class="p">))</span><span class="w">
</span><span class="k">allocate</span><span class="p">(</span><span class="n">sectionResult</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">PARTITION_SIZE</span><span class="p">))</span><span class="w">
</span><span class="k">allocate</span><span class="p">(</span><span class="n">send_request_handles</span><span class="p">(</span><span class="n">numprocs</span><span class="mi">-1</span><span class="p">))</span><span class="w">
</span><span class="k">allocate</span><span class="p">(</span><span class="n">send_request_stats</span><span class="p">(</span><span class="n">MPI_STATUS_SIZE</span><span class="p">,</span><span class="n">numprocs</span><span class="mi">-1</span><span class="p">))</span><span class="w">
</span><span class="k">allocate</span><span class="p">(</span><span class="n">recv_request_stats</span><span class="p">(</span><span class="n">MPI_STATUS_SIZE</span><span class="p">,</span><span class="n">numprocs</span><span class="mi">-1</span><span class="p">))</span><span class="w">
</span><span class="k">allocate</span><span class="p">(</span><span class="n">recv_request_handles</span><span class="p">(</span><span class="n">numprocs</span><span class="mi">-1</span><span class="p">))</span><span class="w">

</span><span class="c1">!--------------------------------------------------------------</span><span class="w">
</span><span class="c1">! 							MAIN CODE</span><span class="w">
</span><span class="c1">!--------------------------------------------------------------</span><span class="w">
</span><span class="c1">! Execute game X number of times as specified by the parameter</span><span class="w">
</span><span class="c1">! "ITERATIONS"</span><span class="w">
</span><span class="k">do</span><span class="p">,</span><span class="w"> </span><span class="n">iter</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">ITERATIONS</span><span class="w">

    </span><span class="c1">!--------------------------------------------------------------</span><span class="w">
    </span><span class="c1">! The Master processor sends sections of the data to each</span><span class="w">
    </span><span class="c1">! processor, receives the processed data from each processor</span><span class="w">
    </span><span class="c1">! and reconstructs the gameboard again for the next</span><span class="w">
    </span><span class="c1">! iteration</span><span class="w">
    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">myid</span><span class="w"> </span><span class="ow">.eq.</span><span class="w"> </span><span class="n">masterProcessor</span><span class="p">)</span><span class="w"> </span><span class="k">then</span><span class="w">

        </span><span class="c1">!--------------------------------------------------------------</span><span class="w">
        </span><span class="c1">! Only initialize gameboard in the first iteration</span><span class="w">
        </span><span class="c1">!--------------------------------------------------------------</span><span class="w">
        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">iter</span><span class="w"> </span><span class="ow">.eq.</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="k">then</span><span class="w">
        
            </span><span class="c1">! Display program configuration</span><span class="w">
            </span><span class="k">call</span><span class="w"> </span><span class="n">displayConfiguration</span><span class="p">()</span><span class="w">
        
            </span><span class="c1">! Initialize gameboard (1=alive, 0=dead)</span><span class="w">
            </span><span class="n">gameBoard</span><span class="p">(:,:)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w">
            </span><span class="k">call</span><span class="w"> </span><span class="n">initializeGameBoard</span><span class="p">(</span><span class="n">gameBoard</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="nb">RANDOM_SEED</span><span class="p">)</span><span class="w">
            </span><span class="k">write</span><span class="p">(</span><span class="o">*</span><span class="p">,</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="s1">'Gameboard after initialization:'</span><span class="w">
            </span><span class="k">call</span><span class="w"> </span><span class="n">printMatrix</span><span class="p">(</span><span class="n">gameBoard</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">)</span><span class="w">
        </span><span class="k">endif</span><span class="w">
        </span><span class="c1">!--------------------------------------------------------------</span><span class="w">



        </span><span class="c1">!--------------------------------------------------------------</span><span class="w">
        </span><span class="c1">! Distribute the data to each processor</span><span class="w">
        </span><span class="c1">!--------------------------------------------------------------</span><span class="w">
        </span><span class="c1">! Note:This could be improved by just using myid and the partition size</span><span class="w">
        </span><span class="c1">! 	to calculate the region of the gameboard that a processor is</span><span class="w">
        </span><span class="c1">! 	supposed to process. However, I make the master processor</span><span class="w">
        </span><span class="c1">! 	the node that controls all other processors and thus</span><span class="w">
        </span><span class="c1">! 	delegates the data to each one</span><span class="w">
        </span><span class="c1">!--------------------------------------------------------------</span><span class="w">
        </span><span class="k">do</span><span class="p">,</span><span class="w"> </span><span class="n">procID</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">numprocs</span><span class="mi">-1</span><span class="w">

            </span><span class="n">lowerLimit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">procID</span><span class="o">*</span><span class="n">PARTITION_SIZE</span><span class="p">)</span><span class="o">-</span><span class="p">(</span><span class="n">PARTITION_SIZE</span><span class="mi">-1</span><span class="p">)</span><span class="w">
            </span><span class="n">upperLimit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">procID</span><span class="o">*</span><span class="n">PARTITION_SIZE</span><span class="w">

            </span><span class="c1">! int MPI_Isend(buffer, count, datatype, dest, tag,</span><span class="w">
            </span><span class="c1">!     MPI_Comm comm, request )</span><span class="w">
            </span><span class="c1">!</span><span class="w">
            </span><span class="c1">! buffer	- Address of send buffer</span><span class="w">
            </span><span class="c1">! count  	- Number of elements in send buffer</span><span class="w">
            </span><span class="c1">! datatype 	- MPI datatype of each send buffer element</span><span class="w">
            </span><span class="c1">! dest   	- Rank of destination</span><span class="w">
            </span><span class="c1">! tag    	- Message tag </span><span class="w">
            </span><span class="c1">! comm   	- PI_Comm communicator</span><span class="w">
            </span><span class="c1">! request   - MPI_Request handle</span><span class="w">
            </span><span class="k">call</span><span class="w"> </span><span class="n">MPI_ISEND</span><span class="p">(</span><span class="n">gameboard</span><span class="p">(:,</span><span class="n">lowerLimit</span><span class="p">:</span><span class="n">upperLimit</span><span class="p">),</span><span class="w"> </span><span class="p">&amp;</span><span class="w"> 
                </span><span class="n">m</span><span class="o">*</span><span class="n">PARTITION_SIZE</span><span class="p">,</span><span class="w"> </span><span class="n">MPI_INTEGER</span><span class="p">,</span><span class="w"> </span><span class="n">procID</span><span class="p">,</span><span class="w"> </span><span class="p">&amp;</span><span class="w"> 
                </span><span class="n">tag</span><span class="p">,</span><span class="w"> </span><span class="n">MPI_COMM_WORLD</span><span class="p">,</span><span class="w"> </span><span class="n">send_request_handles</span><span class="p">(</span><span class="n">procID</span><span class="p">),</span><span class="w"> </span><span class="n">ierr</span><span class="p">)</span><span class="w">
        </span><span class="k">enddo</span><span class="w">

        </span><span class="k">call</span><span class="w"> </span><span class="n">MPI_WAITALL</span><span class="w"> </span><span class="p">(</span><span class="n">numprocs</span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="n">send_request_handles</span><span class="p">,</span><span class="w">  </span><span class="p">&amp;</span><span class="w">
            </span><span class="n">send_request_stats</span><span class="p">,</span><span class="w"> </span><span class="n">ierr</span><span class="p">)</span><span class="w">
        </span><span class="c1">!--------------------------------------------------------------</span><span class="w">


        </span><span class="c1">!--------------------------------------------------------------</span><span class="w">
        </span><span class="c1">! Receive the processed data from each of the processors</span><span class="w">
        </span><span class="c1">!--------------------------------------------------------------</span><span class="w">
        </span><span class="k">do</span><span class="p">,</span><span class="w"> </span><span class="n">procID</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">numprocs</span><span class="mi">-1</span><span class="w">
            </span><span class="k">call</span><span class="w"> </span><span class="n">MPI_IRECV</span><span class="p">(</span><span class="n">block_sections_recv</span><span class="p">(</span><span class="n">procID</span><span class="p">),</span><span class="w"> </span><span class="nb">count</span><span class="p">,</span><span class="w">  </span><span class="p">&amp;</span><span class="w"> 
                </span><span class="n">blockSectionType</span><span class="p">,</span><span class="w"> </span><span class="n">procID</span><span class="p">,</span><span class="w"> </span><span class="n">tag</span><span class="p">,</span><span class="w"> </span><span class="n">MPI_COMM_WORLD</span><span class="p">,</span><span class="w">  </span><span class="p">&amp;</span><span class="w">
                </span><span class="n">recv_request_handles</span><span class="p">(</span><span class="n">procID</span><span class="p">),</span><span class="w"> </span><span class="n">ierr</span><span class="p">)</span><span class="w">
        </span><span class="k">enddo</span><span class="w">

        </span><span class="k">call</span><span class="w"> </span><span class="n">MPI_WAITALL</span><span class="w"> </span><span class="p">(</span><span class="n">numprocs</span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="n">recv_request_handles</span><span class="p">,</span><span class="w"> </span><span class="p">&amp;</span><span class="w"> 
            </span><span class="n">recv_request_stats</span><span class="p">,</span><span class="w"> </span><span class="n">ierr</span><span class="p">)</span><span class="w">


        </span><span class="c1">!!# write(*,*) 'Received Result from processor ', &amp; </span><span class="w">
        </span><span class="c1">!block_sections_recv(1)%id, ' :'</span><span class="w">
        </span><span class="c1">!!# call printMatrix(block_sections_recv(1)%bSection, &amp; </span><span class="w">
        </span><span class="c1">!GAMEBOARD_SIZE,PARTITION_SIZE)</span><span class="w">
        </span><span class="c1">!--------------------------------------------------------------</span><span class="w">


        </span><span class="c1">!--------------------------------------------------------------</span><span class="w">
        </span><span class="c1">! Reconstruct the gameboard with the new data from the processors</span><span class="w">
        </span><span class="c1">!--------------------------------------------------------------</span><span class="w">
        </span><span class="k">do</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">numprocs</span><span class="mi">-1</span><span class="w">
            </span><span class="n">blockID</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">block_sections_recv</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">%</span><span class="n">id</span><span class="w">
            </span><span class="n">lowerLimit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">blockID</span><span class="o">*</span><span class="n">PARTITION_SIZE</span><span class="p">)</span><span class="o">-</span><span class="p">(</span><span class="n">PARTITION_SIZE</span><span class="mi">-1</span><span class="p">)</span><span class="w">
            </span><span class="n">upperLimit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">blockID</span><span class="o">*</span><span class="n">PARTITION_SIZE</span><span class="w">
            </span><span class="n">gameboard</span><span class="p">(:,</span><span class="n">lowerLimit</span><span class="p">:</span><span class="n">upperLimit</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">block_sections_recv</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">%</span><span class="n">bSection</span><span class="w">
        </span><span class="k">enddo</span><span class="w">

        </span><span class="k">write</span><span class="p">(</span><span class="o">*</span><span class="p">,</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="s1">'The gameboard after iteration '</span><span class="p">,</span><span class="w"> </span><span class="n">iter</span><span class="p">,</span><span class="w"> </span><span class="s1">'is: '</span><span class="w">
        </span><span class="k">call</span><span class="w"> </span><span class="n">printMatrix</span><span class="p">(</span><span class="n">gameBoard</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">)</span><span class="w">
        </span><span class="c1">!--------------------------------------------------------------</span><span class="w">

    </span><span class="c1">!--------------------------------------------------------------</span><span class="w">
    </span><span class="c1">! All other processors receive the data from the master processor,</span><span class="w">
    </span><span class="c1">! send/receive data to/from the left and right neighbors, creates</span><span class="w">
    </span><span class="c1">! a ghost cell, processes the data, and send the processed data</span><span class="w">
    </span><span class="c1">! back to the master processor</span><span class="w">
    </span><span class="c1">!--------------------------------------------------------------</span><span class="w">
    </span><span class="k">else</span><span class="w">
        </span><span class="c1">!--------------------------------------------------------------</span><span class="w">
        </span><span class="c1">! Receive the data to process from the master processor</span><span class="w">
        </span><span class="c1">! int MPI_Irecv(buffer, count, datatype, source,</span><span class="w">
        </span><span class="c1">!				tag, comm, request)</span><span class="w">
        </span><span class="c1">!</span><span class="w">
        </span><span class="c1">! buffer 	- Address of receive buffer</span><span class="w">
        </span><span class="c1">! count 	- Number of elements in receive buffer</span><span class="w">
        </span><span class="c1">! datatype 	- MPI_Datatype of each receive buffer element</span><span class="w">
        </span><span class="c1">! source 	- Rank of source</span><span class="w">
        </span><span class="c1">! tag 		- Message tag</span><span class="w">
        </span><span class="c1">! comm 		- MPI_Comm communicator</span><span class="w">
        </span><span class="c1">! request   - MPI_Request handle</span><span class="w">
        </span><span class="k">call</span><span class="w"> </span><span class="n">MPI_IRECV</span><span class="p">(</span><span class="n">boardSection</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="o">*</span><span class="n">PARTITION_SIZE</span><span class="p">,</span><span class="w"> </span><span class="n">MPI_INTEGER</span><span class="p">,</span><span class="w"> </span><span class="p">&amp;</span><span class="w"> 
            </span><span class="n">masterProcessor</span><span class="p">,</span><span class="w"> </span><span class="n">tag</span><span class="p">,</span><span class="w"> </span><span class="n">MPI_COMM_WORLD</span><span class="p">,</span><span class="w"> </span><span class="n">recv_request_handle</span><span class="p">,</span><span class="w"> </span><span class="n">ierr</span><span class="p">)</span><span class="w">

        </span><span class="k">call</span><span class="w"> </span><span class="n">MPI_WAITALL</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">recv_request_handle</span><span class="p">,</span><span class="w"> </span><span class="n">recv_request_stat</span><span class="p">,</span><span class="w"> </span><span class="n">ierr</span><span class="p">)</span><span class="w">

        </span><span class="c1">!write(*,*) 'Data received from master node by ', myid, ' :'</span><span class="w">
        </span><span class="c1">!call printMatrix(boardSection,m,PARTITION_SIZE)</span><span class="w">
        </span><span class="c1">!--------------------------------------------------------------</span><span class="w">



        </span><span class="c1">!--------------------------------------------------------------</span><span class="w">
        </span><span class="c1">! Set correct left and right destination ranks, either neighbors</span><span class="w">
        </span><span class="c1">! to the left and right or wrap around</span><span class="w">
        </span><span class="c1">! If left or right most boundary, the data needs to be wrapped </span><span class="w">
        </span><span class="c1">! around</span><span class="w">
        </span><span class="c1">!--------------------------------------------------------------</span><span class="w">
        </span><span class="c1">! Since assignment of processors is from left to right,</span><span class="w">
        </span><span class="c1">! processor with rank = 1 is the leftmost processor; processor</span><span class="w">
        </span><span class="c1">! with rank = numprocs-1 is the rightmost processor</span><span class="w">
        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">myid</span><span class="w"> </span><span class="ow">.eq.</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="k">then</span><span class="w">

            </span><span class="n">leftDestination</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">numprocs</span><span class="mi">-1</span><span class="w">
            </span><span class="n">rightDestination</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">myid</span><span class="mi">+1</span><span class="w">

        </span><span class="c1">! If rightmost boundary, the data needs to be wrapped around</span><span class="w">
        </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">myid</span><span class="w"> </span><span class="ow">.eq.</span><span class="w"> </span><span class="n">numprocs</span><span class="mi">-1</span><span class="p">)</span><span class="w"> </span><span class="k">then</span><span class="w">

            </span><span class="n">leftDestination</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">myid</span><span class="mi">-1</span><span class="w">
            </span><span class="n">rightDestination</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w">

        </span><span class="c1">! Send data to left and right neighbors</span><span class="w">
        </span><span class="k">else</span><span class="w">
            </span><span class="n">leftDestination</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">myid</span><span class="mi">-1</span><span class="w">
            </span><span class="n">rightDestination</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">myid</span><span class="mi">+1</span><span class="w">
        </span><span class="k">endif</span><span class="w">
        </span><span class="c1">!--------------------------------------------------------------</span><span class="w">



        </span><span class="c1">!--------------------------------------------------------------</span><span class="w">
        </span><span class="c1">! Send left and right columns to the left or right neighbors</span><span class="w">
        </span><span class="c1">! Wrap around if at the edges</span><span class="w">
        </span><span class="c1">!--------------------------------------------------------------</span><span class="w">
        </span><span class="c1">! Copy the leftmost column and send to its left neighbor (numprocs-1)</span><span class="w">
        </span><span class="n">block_column_send</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BlockColumn</span><span class="p">(</span><span class="n">LEFT</span><span class="p">,</span><span class="n">boardSection</span><span class="p">(:,</span><span class="mi">1</span><span class="p">))</span><span class="w">
        </span><span class="k">call</span><span class="w"> </span><span class="n">MPI_ISEND</span><span class="p">(</span><span class="n">block_column_send</span><span class="p">,</span><span class="w"> </span><span class="nb">count</span><span class="p">,</span><span class="w"> </span><span class="n">blockColumnType</span><span class="p">,</span><span class="w">  </span><span class="p">&amp;</span><span class="w"> 
            </span><span class="n">leftDestination</span><span class="p">,</span><span class="w"> </span><span class="n">tag</span><span class="p">,</span><span class="w"> </span><span class="n">MPI_COMM_WORLD</span><span class="p">,</span><span class="w"> </span><span class="n">request_send</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">ierr</span><span class="p">)</span><span class="w">

        </span><span class="c1">! Copy the rightmost column and send to its right neighbor</span><span class="w">
        </span><span class="n">block_column_send</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BlockColumn</span><span class="p">(</span><span class="n">RIGHT</span><span class="p">,</span><span class="n">boardSection</span><span class="p">(:,</span><span class="n">PARTITION_SIZE</span><span class="p">))</span><span class="w">
        </span><span class="k">call</span><span class="w"> </span><span class="n">MPI_ISEND</span><span class="p">(</span><span class="n">block_column_send</span><span class="p">,</span><span class="w"> </span><span class="nb">count</span><span class="p">,</span><span class="w"> </span><span class="n">blockColumnType</span><span class="p">,</span><span class="w"> </span><span class="p">&amp;</span><span class="w"> 
            </span><span class="n">rightDestination</span><span class="p">,</span><span class="w"> </span><span class="n">tag</span><span class="p">,</span><span class="w"> </span><span class="n">MPI_COMM_WORLD</span><span class="p">,</span><span class="w"> </span><span class="n">request_send</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span><span class="w"> </span><span class="n">ierr</span><span class="p">)</span><span class="w">

        </span><span class="c1">! Wait until all the data has been sent</span><span class="w">
        </span><span class="k">call</span><span class="w"> </span><span class="n">MPI_WAITALL</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">request_send</span><span class="p">,</span><span class="w"> </span><span class="n">stat_send</span><span class="p">,</span><span class="w"> </span><span class="n">ierr</span><span class="p">)</span><span class="w">
        </span><span class="c1">!--------------------------------------------------------------</span><span class="w">



        </span><span class="c1">!--------------------------------------------------------------</span><span class="w">
        </span><span class="c1">! Receive left and right data from the neighbors</span><span class="w">
        </span><span class="c1">!--------------------------------------------------------------</span><span class="w">
        </span><span class="c1">! Receive the column data from the neighbors</span><span class="w">
        </span><span class="k">call</span><span class="w"> </span><span class="n">MPI_IRECV</span><span class="p">(</span><span class="n">block_columns_recv</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="nb">count</span><span class="p">,</span><span class="w"> </span><span class="n">blockColumnType</span><span class="p">,</span><span class="w"> </span><span class="p">&amp;</span><span class="w"> 
            </span><span class="n">leftDestination</span><span class="p">,</span><span class="w"> </span><span class="n">tag</span><span class="p">,</span><span class="w"> </span><span class="n">MPI_COMM_WORLD</span><span class="p">,</span><span class="w"> </span><span class="n">request_recv</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">ierr</span><span class="p">)</span><span class="w">

        </span><span class="k">call</span><span class="w"> </span><span class="n">MPI_IRECV</span><span class="p">(</span><span class="n">block_columns_recv</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span><span class="w"> </span><span class="nb">count</span><span class="p">,</span><span class="w"> </span><span class="n">blockColumnType</span><span class="p">,</span><span class="w"> </span><span class="p">&amp;</span><span class="w"> 
            </span><span class="n">rightDestination</span><span class="p">,</span><span class="w"> </span><span class="n">tag</span><span class="p">,</span><span class="w"> </span><span class="n">MPI_COMM_WORLD</span><span class="p">,</span><span class="w"> </span><span class="n">request_recv</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span><span class="w"> </span><span class="n">ierr</span><span class="p">)</span><span class="w">

        </span><span class="c1">! Wait until all the data has been received</span><span class="w">
        </span><span class="k">call</span><span class="w"> </span><span class="n">MPI_WAITALL</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">request_recv</span><span class="p">,</span><span class="w"> </span><span class="n">stat_recv</span><span class="p">,</span><span class="w"> </span><span class="n">ierr</span><span class="p">)</span><span class="w">

        </span><span class="c1">!write(*,*)"processor ",myid," with cellblock ID ", &amp;</span><span class="w">
        </span><span class="c1">!block_columns_recv(1)%id, " has data: ",block_columns_recv(1)%bColumn(:)</span><span class="w">

        </span><span class="c1">!write(*,*)"processor ",myid," with cellblock ID", &amp;</span><span class="w">
        </span><span class="c1">!block_columns_recv(2)%id," has data: ",block_columns_recv(2)%bColumn(:)</span><span class="w">
        </span><span class="c1">!--------------------------------------------------------------</span><span class="w">



        </span><span class="c1">!--------------------------------------------------------------</span><span class="w">
        </span><span class="c1">! Build ghost cell and run the game</span><span class="w">
        </span><span class="c1">!--------------------------------------------------------------</span><span class="w">
        </span><span class="c1">! Once the columns from the left and right have been received, build</span><span class="w">
        </span><span class="c1">! ghost cell and run the game on the data</span><span class="w">
        </span><span class="k">call</span><span class="w"> </span><span class="n">buildGhostCell</span><span class="p">(</span><span class="n">block_columns_recv</span><span class="p">,</span><span class="w"> </span><span class="n">ghostCell</span><span class="p">,</span><span class="w"> </span><span class="n">GAMEBOARD_SIZE</span><span class="p">,</span><span class="w"> </span><span class="p">&amp;</span><span class="w"> 
            </span><span class="n">PARTITION_SIZE</span><span class="p">,</span><span class="w"> </span><span class="n">boardSection</span><span class="p">)</span><span class="w">
        </span><span class="c1">!write(*,*)"The ghost cell is for processor : ", myid</span><span class="w">
        </span><span class="c1">!call printMatrix(ghostCell,GAMEBOARD_SIZE+2,PARTITION_SIZE+2)</span><span class="w">

        </span><span class="k">call</span><span class="w"> </span><span class="n">runGame</span><span class="p">(</span><span class="n">ghostCell</span><span class="p">,</span><span class="w"> </span><span class="n">GAMEBOARD_SIZE</span><span class="mi">+2</span><span class="p">,</span><span class="w"> </span><span class="n">PARTITION_SIZE</span><span class="mi">+2</span><span class="p">,</span><span class="w"> </span><span class="p">&amp;</span><span class="w"> 
            </span><span class="n">sectionResult</span><span class="p">,</span><span class="w"> </span><span class="n">myid</span><span class="p">)</span><span class="w">

        </span><span class="c1">!write(*,*)"The section result is for processor : ", myid</span><span class="w">
        </span><span class="c1">!call printMatrix(sectionResult,GAMEBOARD_SIZE,PARTITION_SIZE)</span><span class="w">
        </span><span class="c1">!--------------------------------------------------------------</span><span class="w">



        </span><span class="c1">!--------------------------------------------------------------</span><span class="w">
        </span><span class="c1">! Send results back to the master node</span><span class="w">
        </span><span class="c1">!--------------------------------------------------------------</span><span class="w">
        </span><span class="n">block_section_send</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">BlockSection</span><span class="p">(</span><span class="n">myid</span><span class="p">,</span><span class="n">sectionResult</span><span class="p">)</span><span class="w">
        </span><span class="k">call</span><span class="w"> </span><span class="n">MPI_ISEND</span><span class="p">(</span><span class="n">block_section_send</span><span class="p">,</span><span class="w"> </span><span class="nb">count</span><span class="p">,</span><span class="w"> </span><span class="n">blockSectionType</span><span class="p">,</span><span class="w"> </span><span class="p">&amp;</span><span class="w">
            </span><span class="n">masterProcessor</span><span class="p">,</span><span class="w"> </span><span class="n">tag</span><span class="p">,</span><span class="w"> </span><span class="n">MPI_COMM_WORLD</span><span class="p">,</span><span class="w"> </span><span class="n">send_request_handle</span><span class="p">,</span><span class="w"> </span><span class="n">ierr</span><span class="p">)</span><span class="w">

        </span><span class="k">call</span><span class="w"> </span><span class="n">MPI_WAITALL</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">send_request_handle</span><span class="p">,</span><span class="w"> </span><span class="n">send_request_stat</span><span class="p">,</span><span class="w"> </span><span class="n">ierr</span><span class="p">)</span><span class="w">
        </span><span class="c1">!--------------------------------------------------------------</span><span class="w">

    </span><span class="k">endif</span><span class="w">

</span><span class="k">enddo</span><span class="w">
</span><span class="c1">!--------------------------------------------------------------</span><span class="w">
</span><span class="c1">! 						END OF MAIN CODE</span><span class="w">
</span><span class="c1">!--------------------------------------------------------------</span><span class="w">

</span><span class="c1">! Free memory</span><span class="w">
</span><span class="k">deallocate</span><span class="w"> </span><span class="p">(</span><span class="n">gameBoard</span><span class="p">,</span><span class="w"> </span><span class="n">ghostCell</span><span class="p">,</span><span class="w"> </span><span class="n">boardSection</span><span class="p">,</span><span class="w"> </span><span class="n">sectionResult</span><span class="p">)</span><span class="w">
</span><span class="k">deallocate</span><span class="w"> </span><span class="p">(</span><span class="n">send_request_handles</span><span class="p">,</span><span class="w"> </span><span class="n">send_request_stats</span><span class="p">)</span><span class="w">
</span><span class="k">deallocate</span><span class="w"> </span><span class="p">(</span><span class="n">recv_request_stats</span><span class="p">,</span><span class="w"> </span><span class="n">recv_request_handles</span><span class="p">)</span><span class="w">

</span><span class="k">call</span><span class="w"> </span><span class="n">MPI_FINALIZE</span><span class="p">(</span><span class="n">ierr</span><span class="p">)</span><span class="w">
    </span><span class="k">stop</span><span class="w">
    
</span><span class="c1">!---------------------------------------------------------------------------------</span><span class="w">
</span><span class="c1">! Subroutines</span><span class="w">
</span><span class="c1">!---------------------------------------------------------------------------------</span><span class="w">
</span><span class="k">CONTAINS</span><span class="w">

</span><span class="c1">!---------------------------------------------------------------------------------</span><span class="w">
</span><span class="c1">! Build ghost cell</span><span class="w">
</span><span class="c1">! Assuming periodic boundary conditions</span><span class="w">
</span><span class="c1">!---------------------------------------------------------------------------------</span><span class="w">
</span><span class="k">subroutine</span><span class="w"> </span><span class="n">buildGhostCell</span><span class="p">(</span><span class="n">blockColumns</span><span class="p">,</span><span class="w"> </span><span class="n">ghostCell</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">boardDataSection</span><span class="p">)</span><span class="w">
    </span><span class="k">implicit</span><span class="w"> </span><span class="k">none</span><span class="w">

    </span><span class="c1">! Declare variables and allocate memory</span><span class="w">
    </span><span class="kt">integer</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">mNew</span><span class="p">,</span><span class="w"> </span><span class="n">nNew</span><span class="w">
    </span><span class="k">type</span><span class="w"> </span><span class="p">(</span><span class="n">BlockColumn</span><span class="p">)</span><span class="w"> </span><span class="n">blockColumns</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="w">
    </span><span class="kt">integer</span><span class="p">,</span><span class="w"> </span><span class="k">dimension</span><span class="p">(</span><span class="n">m</span><span class="mi">+2</span><span class="p">,</span><span class="n">n</span><span class="mi">+2</span><span class="p">)</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">ghostCell</span><span class="w">
    </span><span class="kt">integer</span><span class="p">,</span><span class="w"> </span><span class="k">dimension</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">boardDataSection</span><span class="w">
    </span><span class="kt">integer</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="k">allocatable</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">leftColumn</span><span class="p">(:)</span><span class="w">
    </span><span class="kt">integer</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="k">allocatable</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">rightColumn</span><span class="p">(:)</span><span class="w">

    </span><span class="k">allocate</span><span class="p">(</span><span class="n">leftColumn</span><span class="p">(</span><span class="n">GAMEBOARD_SIZE</span><span class="p">))</span><span class="w">
    </span><span class="k">allocate</span><span class="p">(</span><span class="n">rightColumn</span><span class="p">(</span><span class="n">GAMEBOARD_SIZE</span><span class="p">))</span><span class="w">

    </span><span class="c1">! Ghost cell has a total of 4 edges added around the partition</span><span class="w">
    </span><span class="n">mNew</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="w">
    </span><span class="n">nNew</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="w">

    </span><span class="c1">! Identify left and right sides</span><span class="w">
    </span><span class="c1">! This might not be necessary, but doing so ensures the column</span><span class="w">
    </span><span class="c1">! is appended on the correct side since using asynchronous send/recv</span><span class="w">
    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">blockColumns</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">id</span><span class="w"> </span><span class="ow">.eq.</span><span class="w"> </span><span class="n">LEFT</span><span class="p">)</span><span class="w"> </span><span class="k">then</span><span class="w">
        </span><span class="n">rightColumn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">blockColumns</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">bColumn</span><span class="w">
        </span><span class="n">leftColumn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">blockColumns</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">%</span><span class="n">bColumn</span><span class="w">
    </span><span class="k">else</span><span class="w">
        </span><span class="n">rightColumn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">blockColumns</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">%</span><span class="n">bColumn</span><span class="w">
        </span><span class="n">leftColumn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">blockColumns</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">bColumn</span><span class="w">
    </span><span class="k">endif</span><span class="w">

    </span><span class="c1">! Copy inner elements</span><span class="w">
    </span><span class="n">ghostCell</span><span class="p">(</span><span class="mi">2</span><span class="p">:</span><span class="n">mNew</span><span class="mi">-1</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="n">nNew</span><span class="mi">-1</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">boardDataSection</span><span class="p">(:,:)</span><span class="w">

    </span><span class="c1">! Copy corners</span><span class="w">
    </span><span class="n">ghostCell</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">leftColumn</span><span class="p">(</span><span class="n">m</span><span class="p">)</span><span class="w">
    </span><span class="n">ghostCell</span><span class="p">(</span><span class="n">mNew</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">leftColumn</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w">
    </span><span class="n">ghostCell</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">nNew</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rightColumn</span><span class="p">(</span><span class="n">m</span><span class="p">)</span><span class="w">
    </span><span class="n">ghostCell</span><span class="p">(</span><span class="n">mNew</span><span class="p">,</span><span class="n">nNew</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rightColumn</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w">

    </span><span class="c1">! Copy side elements - wrap around</span><span class="w">
    </span><span class="n">ghostCell</span><span class="p">(</span><span class="mi">2</span><span class="p">:</span><span class="n">mNew</span><span class="mi">-1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">leftColumn</span><span class="w">
    </span><span class="n">ghostCell</span><span class="p">(</span><span class="mi">2</span><span class="p">:</span><span class="n">mNew</span><span class="mi">-1</span><span class="p">,</span><span class="n">nNew</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rightColumn</span><span class="w">

    </span><span class="c1">! Copy upper and lower elements</span><span class="w">
    </span><span class="n">ghostCell</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="n">nNew</span><span class="mi">-1</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">boardDataSection</span><span class="p">(</span><span class="n">m</span><span class="p">,:)</span><span class="w">
    </span><span class="n">ghostCell</span><span class="p">(</span><span class="n">mNew</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="n">nNew</span><span class="mi">-1</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">boardDataSection</span><span class="p">(</span><span class="mi">1</span><span class="p">,:)</span><span class="w">

    </span><span class="c1">! Free memory</span><span class="w">
    </span><span class="k">deallocate</span><span class="w"> </span><span class="p">(</span><span class="n">leftColumn</span><span class="p">,</span><span class="w"> </span><span class="n">rightColumn</span><span class="p">)</span><span class="w">

    </span><span class="k">return</span><span class="w">
</span><span class="k">end</span><span class="w"> </span><span class="k">subroutine</span><span class="w"> </span><span class="n">buildGhostCell</span><span class="w">
</span><span class="c1">!---------------------------------------------------------------------------------</span><span class="w">


</span><span class="c1">!---------------------------------------------------------------------------------</span><span class="w">
</span><span class="c1">! Run the game on the ghostCell</span><span class="w">
</span><span class="c1">!---------------------------------------------------------------------------------</span><span class="w">
</span><span class="k">subroutine</span><span class="w"> </span><span class="n">runGame</span><span class="p">(</span><span class="n">ghostCell</span><span class="p">,</span><span class="w"> </span><span class="n">mGhostCell</span><span class="p">,</span><span class="w"> </span><span class="n">nGhostCell</span><span class="p">,</span><span class="w"> </span><span class="n">sectionResult</span><span class="p">,</span><span class="w"> </span><span class="n">processorID</span><span class="p">)</span><span class="w">
    </span><span class="k">implicit</span><span class="w"> </span><span class="k">none</span><span class="w">
    
    </span><span class="c1">! Declare variables and allocate memory</span><span class="w">
    </span><span class="kt">integer</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="w">
    </span><span class="kt">integer</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">mGhostCell</span><span class="p">,</span><span class="w"> </span><span class="n">nGhostCell</span><span class="p">,</span><span class="w"> </span><span class="n">sumTotal</span><span class="w">
    </span><span class="kt">integer</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">centerCell</span><span class="p">,</span><span class="w"> </span><span class="n">processorID</span><span class="w">
    </span><span class="kt">integer</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="k">dimension</span><span class="p">(</span><span class="n">mGhostCell</span><span class="p">,</span><span class="n">nGhostCell</span><span class="p">)</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">ghostCell</span><span class="w">
    </span><span class="kt">integer</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="k">dimension</span><span class="p">(</span><span class="n">mGhostCell</span><span class="mi">-2</span><span class="p">,</span><span class="n">nGhostCell</span><span class="mi">-2</span><span class="p">)</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">sectionResult</span><span class="w">
    </span><span class="kt">integer</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="k">allocatable</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">window</span><span class="w"> </span><span class="p">(:,:)</span><span class="w">

    </span><span class="c1">! Allocate window to look around eight neighbors</span><span class="w">
    </span><span class="k">allocate</span><span class="p">(</span><span class="n">window</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span><span class="w">
    </span><span class="n">window</span><span class="p">(:,:)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w">
    </span><span class="n">sectionResult</span><span class="p">(:,:)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w">
    </span><span class="n">sumTotal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w">

    </span><span class="c1">! Navigate through the 2D map space</span><span class="w">
    </span><span class="k">do</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="n">mGhostCell</span><span class="mi">-1</span><span class="w">
        </span><span class="k">do</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="n">nGhostCell</span><span class="mi">-1</span><span class="w">

            </span><span class="c1">! Create a window around each grid point</span><span class="w">
            </span><span class="n">window</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ghostCell</span><span class="p">(</span><span class="n">i</span><span class="mi">-1</span><span class="p">:</span><span class="n">i</span><span class="mi">+1</span><span class="p">,</span><span class="n">j</span><span class="mi">-1</span><span class="p">:</span><span class="n">j</span><span class="mi">+1</span><span class="p">)</span><span class="w">
            </span><span class="n">centerCell</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">window</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="c1">!Save indexed cell</span><span class="w">
            </span><span class="n">window</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="c1">!Do not account for the element</span><span class="w">
                            </span><span class="c1">!in the middle. Just look at the </span><span class="w">
                                </span><span class="c1">!8 neighbors</span><span class="w">
            
            </span><span class="c1">! Add the eight neighboring values</span><span class="w">
            </span><span class="n">sumTotal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">sum</span><span class="p">(</span><span class="n">window</span><span class="p">)</span><span class="w">

            </span><span class="c1">! If 3 neighbours are alive, cell will be alive </span><span class="w">
            </span><span class="c1">! (if already alive, remains alive; if was dead, </span><span class="w">
            </span><span class="c1">! becomes alive)</span><span class="w">
            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sumTotal</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="k">then</span><span class="w">
                </span><span class="n">sectionResult</span><span class="p">(</span><span class="n">i</span><span class="mi">-1</span><span class="p">,</span><span class="n">j</span><span class="mi">-1</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w">

            </span><span class="c1">! If 2 neighbours are alive, no change in cell status.</span><span class="w">
            </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sumTotal</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="k">then</span><span class="w">
                </span><span class="n">sectionResult</span><span class="p">(</span><span class="n">i</span><span class="mi">-1</span><span class="p">,</span><span class="n">j</span><span class="mi">-1</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">centerCell</span><span class="w">

            </span><span class="c1">! All other cases, cell is dead (if was dead, remains </span><span class="w">
            </span><span class="c1">! dead; if was alive, becomes dead)</span><span class="w">
            </span><span class="k">else</span><span class="w">
                </span><span class="n">sectionResult</span><span class="p">(</span><span class="n">i</span><span class="mi">-1</span><span class="p">,</span><span class="n">j</span><span class="mi">-1</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w">
            </span><span class="k">end</span><span class="w"> </span><span class="k">if</span><span class="w">
        </span><span class="k">enddo</span><span class="w">
    </span><span class="k">enddo</span><span class="w">

    </span><span class="c1">! Show total number of alive cells in the gameboard</span><span class="w">
    </span><span class="n">sumTotal</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">sum</span><span class="p">(</span><span class="n">sectionResult</span><span class="p">)</span><span class="w">
    </span><span class="k">write</span><span class="p">(</span><span class="o">*</span><span class="p">,</span><span class="s2">"(A)"</span><span class="p">)</span><span class="w"> </span><span class="s1">'---------------------------------------------------'</span><span class="w">
    </span><span class="k">write</span><span class="p">(</span><span class="o">*</span><span class="p">,</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="s1">'Total number of alive cells from processor '</span><span class="p">,</span><span class="w"> </span><span class="p">&amp;</span><span class="w"> 
                </span><span class="n">processorID</span><span class="p">,</span><span class="w"> </span><span class="s1">' is: '</span><span class="p">,</span><span class="w"> </span><span class="n">sumTotal</span><span class="w">
    </span><span class="k">write</span><span class="p">(</span><span class="o">*</span><span class="p">,</span><span class="s2">"(A)"</span><span class="p">)</span><span class="w"> </span><span class="s1">'---------------------------------------------------'</span><span class="w">

    </span><span class="c1">!Free memory</span><span class="w">
    </span><span class="k">deallocate</span><span class="w"> </span><span class="p">(</span><span class="n">window</span><span class="p">)</span><span class="w">

    </span><span class="k">return</span><span class="w">
</span><span class="k">end</span><span class="w"> </span><span class="k">subroutine</span><span class="w"> </span><span class="n">runGame</span><span class="w">
</span><span class="c1">!---------------------------------------------------------------------------------</span><span class="w">


</span><span class="c1">!---------------------------------------------------------------------------------</span><span class="w">
</span><span class="c1">! Assigns random 1s to 50% of the matrix</span><span class="w">
</span><span class="c1">!---------------------------------------------------------------------------------</span><span class="w">
</span><span class="k">subroutine</span><span class="w"> </span><span class="n">initializeGameBoard</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">seed</span><span class="p">)</span><span class="w"> 
    </span><span class="k">implicit</span><span class="w"> </span><span class="k">none</span><span class="w">

    </span><span class="kt">integer</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="w">
    </span><span class="kt">integer</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">mat</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">)</span><span class="w">
    </span><span class="kt">integer</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">totalSize</span><span class="p">,</span><span class="w"> </span><span class="n">seed</span><span class="w">

    </span><span class="n">totalSize</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m</span><span class="o">*</span><span class="n">n</span><span class="w">

    </span><span class="c1">!Randomly assign 1 to 50% of the cells</span><span class="w">
    </span><span class="k">call</span><span class="w"> </span><span class="n">srand</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span><span class="w">
    </span><span class="k">do</span><span class="w"> </span><span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="nb">ceiling</span><span class="p">(</span><span class="n">totalSize</span><span class="o">*</span><span class="mf">0.50</span><span class="p">)</span><span class="w">
        </span><span class="n">mat</span><span class="p">(</span><span class="nb">ceiling</span><span class="p">(</span><span class="n">rand</span><span class="p">()</span><span class="o">*</span><span class="n">m</span><span class="p">),</span><span class="nb">ceiling</span><span class="p">(</span><span class="n">rand</span><span class="p">()</span><span class="o">*</span><span class="n">n</span><span class="p">))</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w">
    </span><span class="k">enddo</span><span class="w">

    </span><span class="k">return</span><span class="w">
</span><span class="k">end</span><span class="w"> </span><span class="k">subroutine</span><span class="w"> </span><span class="n">initializeGameBoard</span><span class="w">
</span><span class="c1">!---------------------------------------------------------------------------------</span><span class="w">


</span><span class="c1">!---------------------------------------------------------------------------------</span><span class="w">
</span><span class="c1">! Prints a matrix of size mxn to the screen</span><span class="w">
</span><span class="c1">!---------------------------------------------------------------------------------</span><span class="w">
</span><span class="k">subroutine</span><span class="w"> </span><span class="n">printMatrix</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">)</span><span class="w">
    </span><span class="k">implicit</span><span class="w"> </span><span class="k">none</span><span class="w">

    </span><span class="kt">INTEGER</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="w">
    </span><span class="kt">INTEGER</span><span class="p">,</span><span class="w"> </span><span class="k">DIMENSION</span><span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">mat</span><span class="w">

    </span><span class="k">write</span><span class="p">(</span><span class="o">*</span><span class="p">,</span><span class="s2">"(A)"</span><span class="p">)</span><span class="w"> </span><span class="s1">'---------------------------------------------------'</span><span class="w">
    </span><span class="k">do</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">m</span><span class="w">
        </span><span class="k">write</span><span class="p">(</span><span class="o">*</span><span class="p">,</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">mat</span><span class="p">(</span><span class="n">i</span><span class="p">,:))</span><span class="w">
    </span><span class="k">enddo</span><span class="w">
    </span><span class="k">write</span><span class="p">(</span><span class="o">*</span><span class="p">,</span><span class="s2">"(A)"</span><span class="p">)</span><span class="w"> </span><span class="s1">'---------------------------------------------------'</span><span class="w">
    </span><span class="k">write</span><span class="p">(</span><span class="o">*</span><span class="p">,</span><span class="s2">"(A)"</span><span class="p">)</span><span class="w"> </span><span class="s1">''</span><span class="w">

    </span><span class="k">return</span><span class="w">
</span><span class="k">end</span><span class="w"> </span><span class="k">subroutine</span><span class="w"> </span><span class="n">printMatrix</span><span class="w">
</span><span class="c1">!---------------------------------------------------------------------------------</span><span class="w">


</span><span class="c1">!---------------------------------------------------------------------------------</span><span class="w">
</span><span class="c1">! Show configuration of the program</span><span class="w">
</span><span class="c1">!---------------------------------------------------------------------------------</span><span class="w">
</span><span class="k">subroutine</span><span class="w"> </span><span class="n">displayConfiguration</span><span class="p">()</span><span class="w">
    </span><span class="k">implicit</span><span class="w"> </span><span class="k">none</span><span class="w">

    </span><span class="k">write</span><span class="p">(</span><span class="o">*</span><span class="p">,</span><span class="s2">"(A)"</span><span class="p">)</span><span class="w"> </span><span class="s1">'---------------------------------------------------'</span><span class="w">
    </span><span class="k">write</span><span class="p">(</span><span class="o">*</span><span class="p">,</span><span class="s2">"(A)"</span><span class="p">)</span><span class="w"> </span><span class="s1">'Program configuration: '</span><span class="w">
    </span><span class="k">write</span><span class="p">(</span><span class="o">*</span><span class="p">,</span><span class="s2">"(A)"</span><span class="p">)</span><span class="w"> </span><span class="s1">'---------------------------------------------------'</span><span class="w">
    </span><span class="k">write</span><span class="p">(</span><span class="o">*</span><span class="p">,</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="s1">'Game board size:'</span><span class="p">,</span><span class="w"> </span><span class="n">GAMEBOARD_SIZE</span><span class="p">,</span><span class="w"> </span><span class="s1">' x '</span><span class="p">,</span><span class="w"> </span><span class="n">GAMEBOARD_SIZE</span><span class="w">
    </span><span class="k">write</span><span class="p">(</span><span class="o">*</span><span class="p">,</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="s1">'Partition size:'</span><span class="p">,</span><span class="w"> </span><span class="n">PARTITION_SIZE</span><span class="p">,</span><span class="w"> </span><span class="s1">' x '</span><span class="p">,</span><span class="w"> </span><span class="n">GAMEBOARD_SIZE</span><span class="w">
    </span><span class="k">write</span><span class="p">(</span><span class="o">*</span><span class="p">,</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="s1">'Number of iterations:'</span><span class="p">,</span><span class="w"> </span><span class="n">ITERATIONS</span><span class="w">
    </span><span class="k">write</span><span class="p">(</span><span class="o">*</span><span class="p">,</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="s1">'Number of required processors:'</span><span class="p">,</span><span class="w"> </span><span class="n">GAMEBOARD_SIZE</span><span class="p">/</span><span class="w"> </span><span class="p">&amp;</span><span class="w">
                                                </span><span class="n">PARTITION_SIZE</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w">
    </span><span class="k">write</span><span class="p">(</span><span class="o">*</span><span class="p">,</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="s1">'Pseudorandom seed used:'</span><span class="p">,</span><span class="w"> </span><span class="nb">RANDOM_SEED</span><span class="w">
    </span><span class="k">write</span><span class="p">(</span><span class="o">*</span><span class="p">,</span><span class="s2">"(A)"</span><span class="p">)</span><span class="w"> </span><span class="s1">'---------------------------------------------------'</span><span class="w">
    </span><span class="k">write</span><span class="p">(</span><span class="o">*</span><span class="p">,</span><span class="s2">"(A)"</span><span class="p">)</span><span class="w"> </span><span class="s1">''</span><span class="w">

    </span><span class="k">return</span><span class="w">
</span><span class="k">end</span><span class="w"> </span><span class="k">subroutine</span><span class="w"> </span><span class="n">displayConfiguration</span><span class="w">
</span><span class="c1">!---------------------------------------------------------------------------------</span><span class="w">

</span><span class="k">END</span><span class="w"> </span><span class="k">PROGRAM</span><span class="w"> </span><span class="n">parallel1DGoL</span>
</pre></td>
</tr></tbody></table></code></pre></figure>

            </div>
        </div>
    </div>
</div>
<p><br></p>
<h2>Conclusion</h2>
<hr class="bg-danger border-2 border-top border-primary-subtle">

<p>This project shows how to design and implement parallel algorithms using the PCAM process, Fortran, and MPI. I hope this inspires you to learn more about Fortran and experiment creating parallel programming projects. If you are interested in seeing the source code for parallel2DGoL.f90, or you have any questions, please send me an e-mail.
<br></p>
<h2>References</h2>
<hr class="bg-danger border-2 border-top border-primary-subtle">

<p>[1] <a href="https://www.fortran90.org" rel="external nofollow noopener" target="_blank">Fortran 90</a>
<br>
[2] <a href="https://www.open-mpi.org" rel="external nofollow noopener" target="_blank">Open MPI</a></p>

          </article>

        </div>

    </div>

    <!-- Footer -->    
    <footer class="fixed-bottom">
      <div class="container mt-0" style="text-align:center;">
        © Copyright 2023 Germán H. Flores. 
      </div>
    </footer>

    <!-- JavaScripts -->
    <!-- jQuery -->
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>

    <!-- Bootsrap & MDB scripts -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js" integrity="sha384-w76AqPfDkMBDXo30jS1Sgez6pr3x5MlQ1ZAGC+nuZB+EYdgRZgiwxhTBTkF7CXvN" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script>

    <!-- Masonry & imagesLoaded -->
  <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script>
  <script defer src="/assets/js/masonry.js" type="text/javascript"></script>
    
  <!-- Medium Zoom JS -->
  <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script>
  <script defer src="/assets/js/zoom.js"></script><!-- Load Common JS -->
  <script defer src="/assets/js/common.js"></script>
  <script defer src="/assets/js/copy_code.js" type="text/javascript"></script>

    

    <!-- MathJax -->
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        tags: 'ams',
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      },
      svg: {
		    fontCache: 'global'
	    }
};
  </script>
  <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script>
  <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>

    
    

<!-- Scrolling Progress Bar -->
<script type="text/javascript">
  /*
   * This JavaScript code has been adapted from the article 
   * https://css-tricks.com/reading-position-indicator/ authored by Pankaj Parashar, 
   * published on the website https://css-tricks.com on the 7th of May, 2014.
   * Couple of changes were made to the original code to make it compatible 
   * with the `al-foio` theme.
   */
  const progressBar = $("#progress");
  /*
   * We set up the bar after all elements are done loading.
   * In some cases, if the images in the page are larger than the intended
   * size they'll have on the page, they'll be resized via CSS to accomodate
   * the desired size. This mistake, however, breaks the computations as the
   * scroll size is computed as soon as the elements finish loading.
   * To account for this, a minimal delay was introduced before computing the
   * values.
   */
  window.onload = function () {
    setTimeout(progressBarSetup, 50);
  };
  /*
   * We set up the bar according to the browser.
   * If the browser supports the progress element we use that.
   * Otherwise, we resize the bar thru CSS styling
   */
  function progressBarSetup() {
    if ("max" in document.createElement("progress")) {
      initializeProgressElement();
      $(document).on("scroll", function() {
        progressBar.attr({ value: getCurrentScrollPosition() });
      });
      $(window).on("resize", initializeProgressElement);
    } else {
      resizeProgressBar();
      $(document).on("scroll", resizeProgressBar);
      $(window).on("resize", resizeProgressBar);
    }
  }
  /*
   * The vertical scroll position is the same as the number of pixels that
   * are hidden from view above the scrollable area. Thus, a value > 0 is
   * how much the user has scrolled from the top
   */
  function getCurrentScrollPosition() {
    return $(window).scrollTop();
  }

  function initializeProgressElement() {
    let navbarHeight = $("#navbar").outerHeight(true);
    $("body").css({ "padding-top": navbarHeight });
    $("progress-container").css({ "padding-top": navbarHeight });
    progressBar.css({ top: navbarHeight });
    progressBar.attr({
      max: getDistanceToScroll(),
      value: getCurrentScrollPosition(),
    });
  }
  /*
   * The offset between the html document height and the browser viewport
   * height will be greater than zero if vertical scroll is possible.
   * This is the distance the user can scroll
   */
  function getDistanceToScroll() {
    return $(document).height() - $(window).height();
  }

  function resizeProgressBar() {
    progressBar.css({ width: getWidthPercentage() + "%" });
  }
  // The scroll ratio equals the percentage to resize the bar
  function getWidthPercentage() {
    return (getCurrentScrollPosition() / getDistanceToScroll()) * 100;
  }
</script>

  </body>
</html>
